<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>moOde‚Ñ¢ Podcast Add-On</title>

<style>
  :root{
    --bg: #0b1220;
    --bg2:#070b14;

    --panel: rgba(255,255,255,.06);
    --panel2: rgba(255,255,255,.08);
    --subsShell: rgba(255,255,255,.095);
    --border: rgba(255,255,255,.12);

    --text: rgba(255,255,255,.92);
    --muted: rgba(255,255,255,.65);
    --muted2: rgba(255,255,255,.48);

    --accent: #7dd3fc;
    --accent2:#a78bfa;
    --ok: #34d399;
    --err: #fb7185;

    --shadow: 0 10px 30px rgba(0,0,0,.35);
    --radius: 14px;
    --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  }

  *{ box-sizing:border-box; }
  html, body { height: 100%; }
  html { min-height: 100%; }

  body{
    margin:0;
    min-height: 100vh;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    color: var(--text);

    background:
      radial-gradient(1200px 600px at 20% 0%, rgba(125,211,252,.18), transparent 60%),
      radial-gradient(1000px 600px at 90% 10%, rgba(167,139,250,.14), transparent 55%),
      radial-gradient(900px 600px at 50% 110%, rgba(52,211,153,.10), transparent 60%),
      linear-gradient(180deg, #081021 0%, var(--bg2) 100%);
    background-attachment: fixed;

    display: grid;
    grid-template-rows: auto 1fr;
  }

  /* ---------- HERO RAIL (LOCKED) ---------- */
  .heroRail{
    position: sticky;
    top: 0;
    z-index: 50;
    background: rgba(3, 7, 18, .70);
    backdrop-filter: blur(10px);
    border-bottom: 1px solid rgba(255,255,255,.10);
  }

  .heroWrap{
    max-width: 1080px;
    margin: 0 auto;
    padding: 18px 18px 14px;
  }

  header{
    display:flex;
    align-items:flex-end;
    justify-content:space-between;
    gap:16px;
    margin-bottom: 14px;
  }

  .brand{ display:flex; flex-direction:column; gap:4px; min-width:0; }
  .brand h1{
    margin:0;
    font-size: 20px;
    letter-spacing:.2px;
    line-height: 1.15;
    font-weight: 780;
  }
  .brand .sub{
    font-size: 13px;
    color: var(--muted);
    line-height: 1.3;
    max-width: 70ch;
  }

  .pill{
    display:inline-flex;
    align-items:center;
    gap:8px;
    padding: 7px 10px;
    border-radius: 999px;
    background: rgba(255,255,255,.06);
    border: 1px solid rgba(255,255,255,.10);
    color: var(--muted);
    font-size: 12px;
    white-space: nowrap;
  }
  .dot{
    width: 8px; height: 8px;
    border-radius: 999px;
    background: var(--accent);
    box-shadow: 0 0 0 4px rgba(125,211,252,.12);
  }

  .panel{
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    overflow: hidden;
  }

  .controls{
    padding: 12px;
    display:flex;
    flex-direction:column;
    gap:10px;
  }

  .row{
    display:flex;
    gap:10px;
    align-items: center;
    flex-wrap: wrap;
  }

  .field{
    display:flex;
    flex-direction: column;
    gap:6px;
    min-width: 0;
  }

  .field label{
    font-size: 12px;
    color: var(--muted);
    letter-spacing: .2px;
    display:flex;
    align-items:center;
    gap:8px;
  }

  input[type="url"]{
    flex: 1 1 520px;
    width: min(900px, 100%);

    font-size: 15px;

    /* üîí lock height */
    height: 30px;
    min-height: 30px;
    max-height: 30px;

    line-height: 20px;
    padding: 10px 12px;
    box-sizing: border-box;
  }

  input[type="url"]{
    flex: 1 1 520px;
    width: min(900px, 100%);
    font-size: 15px;
    line-height: 1.2;
  }

  input[type="number"]{
    width: 120px;
    font-size: 14px;
  }

  input:focus{
    border-color: rgba(125,211,252,.55);
    background: rgba(0,0,0,.28);
  }

  .btn{
    height: 40px;
    padding: 10px 12px;
    border-radius: 12px;
    border: 1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.06);
    color: var(--text);
    cursor: pointer;
    font-size: 14px;
    font-weight: 650;
    letter-spacing: .2px;
    display:inline-flex;
    align-items:center;
    justify-content:center;
    gap:8px;
    white-space:nowrap;
    user-select:none;
  }
  .btn:hover{
    background: rgba(255,255,255,.10);
    border-color: rgba(255,255,255,.20);
  }

  /* keyboard focus */
  .btn:focus-visible,
  input:focus-visible{
    outline: 2px solid rgba(125,211,252,.55);
    outline-offset: 2px;
  }

  .btnPrimary{
    border-color: rgba(125,211,252,.35);
    background: linear-gradient(135deg, rgba(125,211,252,.22), rgba(167,139,250,.18));
  }
  .btnPrimary:hover{
    border-color: rgba(125,211,252,.55);
    background: linear-gradient(135deg, rgba(125,211,252,.28), rgba(167,139,250,.22));
  }

  .btnDanger{
    border-color: rgba(251,113,133,.40);
    background: rgba(251,113,133,.10);
  }
  .btnDanger:hover{
    border-color: rgba(251,113,133,.65);
    background: rgba(251,113,133,.16);
  }

  .statusRow{
    display:flex;
    align-items:center;
    gap:10px;
    padding: 10px 12px;
    border-top: 1px solid rgba(255,255,255,.10);
    background: rgba(0,0,0,.12);
  }

  .spinner{
    width: 14px;
    height: 14px;
    border: 2px solid rgba(255,255,255,.25);
    border-top-color: rgba(255,255,255,.85);
    border-radius: 50%;
    animation: spin .8s linear infinite;
    display: none;
    flex: 0 0 auto;
  }
  .busy .spinner{ display:inline-block; }
  @keyframes spin { to { transform: rotate(360deg); } }

  .statusText{ font-size: 13px; color: var(--muted); }
  .statusText.ok{ color: var(--ok); }
  .statusText.err{ color: var(--err); }

  pre#log{
    margin: 12px 0 0;
    padding: 12px;
    background: rgba(0,0,0,.40);
    border: 1px solid rgba(255,255,255,.12);
    color: rgba(180,255,200,.92);
    font-size: 12px;
    max-height: 180px;
    overflow: auto;
    border-radius: var(--radius);
    white-space: pre-wrap;
    box-shadow: var(--shadow);
    font-family: var(--mono);
  }

  .divider{
    margin: 14px 0 0;
    height: 1px;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,.18), transparent);
  }

  /* ---------- SUBS SCROLLER ---------- */
  .subsScroll{
    overflow: auto;
    -webkit-overflow-scrolling: touch;
  }

  .subsWrap{
    max-width: 1080px;
    margin: 0 auto;
    padding: 14px 18px 28px;
  }

  .subsShell{
    background: var(--subsShell);
    border: 1px solid rgba(255,255,255,.12);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    padding: 14px;
  }

  .subsHeader{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
    margin-bottom: 10px;
  }
  .subsHeader .h{
    font-weight: 760;
    font-size: 13px;
    letter-spacing:.18px;
    color: rgba(255,255,255,.86);
  }
  .subsHeader .hint{
    font-size: 12px;
    color: var(--muted2);
  }

  .grid{
    display:grid;
    grid-template-columns: 1fr;
    gap: 12px;
  }

  .card{
    background: rgba(0,0,0,.20);
    border: 1px solid rgba(255,255,255,.12);
    border-radius: var(--radius);
    overflow: hidden;
    cursor: pointer;
  }
  .card:hover{
    border-color: rgba(255,255,255,.20);
    background: rgba(0,0,0,.24);
  }

  .cardHead{
    display:flex;
    align-items:center;
    gap: 12px;
    padding: 12px;
    background: rgba(255,255,255,.04);
    border-bottom: 1px solid rgba(255,255,255,.08);
  }

  .thumb{
    width: 56px;
    height: 56px;
    border-radius: 12px;
    object-fit: cover;
    flex: 0 0 auto;
    border: 1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.06);
  }

  .cardTitleWrap{ min-width:0; flex:1 1 auto; }
  .cardTitle{
    font-weight: 780;
    font-size: 14px;
    line-height: 1.25;
    margin: 0 0 3px;
    overflow:hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .cardSub{
    font-size: 12px;
    color: var(--muted2);
    overflow:hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .cardBody{
    padding: 12px;
    display:grid;
    gap: 8px;
    font-size: 13px;
    color: var(--muted);
  }
  .metaLine{ display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
  .metaKey{ color: var(--muted2); width: 52px; flex: 0 0 auto; }

  .empty{
    padding: 14px;
    color: var(--muted);
    font-size: 13px;
  }

  .busy .btn, .busy input { opacity: .92; }
  .busy .btn:disabled, .busy input:disabled { opacity: .55; cursor:not-allowed; }

  @media (max-width: 520px){
    header{ align-items:flex-start; flex-direction: column; }
    .pill{ align-self:flex-start; }
    input[type="number"]{ width: 110px; }
    .subsHeader{ flex-direction:column; align-items:flex-start; }
    pre#log{ max-height: 150px; }
  }

  /* =========================
     Modal
     ========================= */

  /* IMPORTANT: lock the actual scroller when modal is open */
  body.modal-open .subsScroll{ overflow: hidden; }

  .modalBusy{
    display: none;
    align-items: center;
    gap: 10px;
    padding: 10px 0 0;
  }

  .modalBusy.on{ display: flex; }

  /* ensure spinner visible in modal too */
  .modalBusy .spinner{
    display: inline-block;
  }

  .modalOverlay{
    position: fixed;
    inset: 0;
    z-index: 9999;
    display: none;
    align-items: center;
    justify-content: center;
    padding: 18px;

    background: rgba(0,0,0,.55);
    backdrop-filter: blur(6px);
  }

  .modalOverlay.open{ display: flex; }

  .modal{
    width: min(920px, 100%);
    max-height: min(78vh, 820px);
    overflow: hidden;

    border-radius: var(--radius);
    border: 1px solid rgba(255,255,255,.14);
    background: rgba(10,16,28,.92);
    box-shadow: 0 20px 60px rgba(0,0,0,.55);

    display: flex;
    flex-direction: column;
  }

  .modalHead{
    display:flex;
    gap: 12px;
    align-items:center;
    padding: 12px 14px;
    border-bottom: 1px solid rgba(255,255,255,.10);
    background: rgba(255,255,255,.04);
  }

  .modalTitleWrap{ min-width:0; flex: 1 1 auto; }

  .modalTitle{
    margin:0;
    font-size: 15px;
    font-weight: 780;
    line-height: 1.2;
    overflow:hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .modalSub{
    font-size: 12px;
    color: var(--muted2);
    overflow:hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .modalClose{
    height: 36px;
    min-width: 36px;
    border-radius: 12px;
    border: 1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.06);
    color: var(--text);
    cursor: pointer;
    font-weight: 800;

    display:inline-flex;
    align-items:center;
    justify-content:center;
  }

  .modalClose:hover{
    background: rgba(255,255,255,.10);
    border-color: rgba(255,255,255,.20);
  }

  .modalBody{
    padding: 12px 14px 14px;
    overflow: auto;
  }

  .modalActions{
    display:flex;
    gap: 10px;
    align-items:center;
    justify-content: space-between;
    padding: 10px 14px;
    border-top: 1px solid rgba(255,255,255,.10);
    background: rgba(0,0,0,.16);
  }

  .btnIcon{
    width: 40px;
    min-width: 40px;
    padding: 0;
    display:inline-flex;
    align-items:center;
    justify-content:center;
    font-size: 16px;
    line-height: 1;
  }

  .epList{
    display:grid;
    gap: 10px;
    margin-top: 10px;
  }

  .epRow{
    display: grid;
    grid-template-columns: 22px 1fr auto;
    gap: 10px;
    align-items: start;

    padding: 10px;
    border-radius: 12px;
    border: 1px solid rgba(255,255,255,.12);
    background: rgba(0,0,0,.18);
  }

  .epChk{
    width: 18px;
    height: 18px;
    margin-top: 2px;
    accent-color: var(--accent);
  }

  .epMain{ min-width: 0; }

  .epTitle{
    font-size: 13px;
    font-weight: 720;
    line-height: 1.25;
    margin: 0 0 4px;
    overflow:hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .epMeta{
    font-size: 12px;
    color: var(--muted2);
    overflow:hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .epRight{
    font-size: 12px;
    color: var(--muted2);
    white-space: nowrap;
    margin-top: 2px;
  }

  .tinyMuted{
    font-size: 12px;
    color: var(--muted2);
  }
  
  input[type="url"],
input[type="number"] {
  color: var(--text);
  background: rgba(0,0,0,.28);
  border: 1px solid rgba(255,255,255,.18);
}

input::placeholder {
  color: var(--muted2);
}

.epRow.epDownloaded {
  background: linear-gradient(
    180deg,
    rgba(0, 160, 90, 0.10),
    rgba(0, 160, 90, 0.05)
  );
  border-left: 4px solid rgba(0, 160, 90, 0.6);
}

.epRow.epDownloaded .epMeta {
  color: #808080;
  font-weight: 500;
}
.epRight {
  display: flex;
  align-items: center;
  gap: 10px;
}

.epPlayBtn {
  border: 0;
  background: transparent;
  padding: 4px;
  cursor: pointer;
}

.epPlayBtn svg {
  width: 24px;
  height: 24px;
  fill: #bbb
}
</style>

</head>

<body>
  <!-- LOCKED HERO -->
  <div class="heroRail" id="heroRail">
    <div class="heroWrap">
      <header>
        <div class="brand">
          <h1>moOde‚Ñ¢ Podcast Add-On</h1>
          <div class="sub">
            Subscribe ‚Üí download to USB ‚Üí generate moOde playlists. No podcast apps, no streaming at playback time.
          </div>
        </div>

        <div class="pill" title="UI on :8000 ‚Üí API on :3000">
          <span class="dot" aria-hidden="true"></span>
          Pi4 API: <span id="apiHint" style="color:rgba(255,255,255,.85)">10.0.0.233:3000</span>
        </div>
      </header>

      <section class="panel" id="heroPanel">
        <div class="controls">
          <div class="row">
            <div class="field" style="flex:1 1 auto;">
              <label for="rss">RSS URL</label>
              <input
                id="rss"
                type="url"
                placeholder="Paste RSS URL to subscribe‚Ä¶"
                autocomplete="off"
              />
            </div>

            <div class="field">
              <label for="download">Download</label>
              <input id="download" type="number" min="0" max="50" step="1" value="5" />
            </div>

            <div class="field">
              <label for="limit" title="How many items to scan from the RSS feed (used during subscribe/refresh)">
                Feed scan
              </label>
              <input id="limit" type="number" min="1" max="500" step="1" value="50" />
            </div>

            <button class="btn btnPrimary" id="btnSub" type="button">Subscribe</button>
            <button class="btn" id="btnRefresh" type="button">Refresh</button>
          </div>
        </div>

        <div class="statusRow" id="statusWrap">
          <div class="spinner" aria-hidden="true"></div>
          <div id="status" class="statusText">Loading‚Ä¶</div>
        </div>
      </section>

      <pre id="log" aria-label="Request log"></pre>
      <div class="divider" aria-hidden="true"></div>
    </div>
  </div>

  <!-- SCROLLING SUBS (behind hero) -->
  <div class="subsScroll" id="subsScroll">
    <div class="subsWrap">
      <section class="subsShell">
        <div class="subsHeader">
          <div class="h">Subscriptions</div>
          <div class="hint">
            Shows: <span id="subCount">0</span> ‚Ä¢ Files counted on load (via /podcasts/refresh)
          </div>
        </div>
        <div class="grid" id="list"></div>
      </section>
    </div>
  </div>

  <!-- Modal -->
  <div class="modalOverlay" id="modalOverlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-label="Podcast details">
      <div class="modalHead">
        <img class="thumb" id="modalThumb" alt="" />
        <div class="modalTitleWrap">
          <div class="modalTitle" id="modalTitle">Podcast</div>
          <div class="modalSub" id="modalSub"></div>
        </div>
        <button class="modalClose" id="modalClose" type="button" aria-label="Close">‚úï</button>
      </div>

      <div class="modalBody">
        <div class="modalBusy" id="modalBusy" aria-live="polite">
          <span class="spinner" aria-hidden="true"></span>
          <div class="tinyMuted" id="modalHint">Loading‚Ä¶</div>
        </div>
        <div class="epList" id="epList"></div>
      </div>

      <div class="modalActions">
        <div class="tinyMuted" id="modalCount"></div>
        <div style="display:flex; gap:10px;">
          <button class="btn" id="modalRefresh" type="button">Refresh</button>
          <button class="btn" id="modalSelectAll" type="button" title="Select all episodes">Select all</button>
          <button class="btn btnPrimary" id="modalDownloadSelected" type="button" disabled title="Download selected episodes">
            Download selected
          </button>
          <button class="btn btnDanger" id="modalDeleteSelected" type="button" disabled title="Delete selected episodes">
            üóë
          </button>
        </div>
      </div>
    </div>
  </div>
</body>
<script>
  console.log('PODCASTS_UI_VERSION', '2026-02-04_1');
  const statusEl   = document.getElementById('status');
  const statusWrap = document.getElementById('statusWrap');
  const listEl     = document.getElementById('list');
  const subCountEl = document.getElementById('subCount');

  const rssEl      = document.getElementById('rss');
  const dlEl       = document.getElementById('download');
  const limitEl    = document.getElementById('limit');
  const logEl      = document.getElementById('log');

  const btnSub     = document.getElementById('btnSub');
  const btnRefresh = document.getElementById('btnRefresh');

  const API_BASE = 'http://10.0.0.233:3000';

  // =========================
  // Modal
  // =========================
  const modalOverlay = document.getElementById('modalOverlay');
  const modalClose   = document.getElementById('modalClose');
  const modalTitle   = document.getElementById('modalTitle');
  const modalSub     = document.getElementById('modalSub');
  const modalHint    = document.getElementById('modalHint');
  const epList       = document.getElementById('epList');
  const modalCount   = document.getElementById('modalCount');
  const modalThumb   = document.getElementById('modalThumb');

  const modalRefresh          = document.getElementById('modalRefresh');
  const modalSelectAll        = document.getElementById('modalSelectAll');
  const modalDownloadSelected = document.getElementById('modalDownloadSelected');
  const modalDeleteSelected   = document.getElementById('modalDeleteSelected');

  let modalCtx = null;     // { rss, title, imageUrl, mapJson, limit }
  let lastEpisodes = [];   // list currently rendered
  
  
  
  function openModal(ctx) {
    modalCtx = ctx || null;

    modalTitle.textContent = (ctx && ctx.title) ? ctx.title : 'Podcast';
    modalSub.textContent   = (ctx && ctx.rss) ? ctx.rss : '';

    modalThumb.src = (ctx && ctx.imageUrl)
      ? ctx.imageUrl
      : placeholderSvgDataUri(modalTitle.textContent);

    modalHint.textContent = 'Loading‚Ä¶';
    epList.innerHTML = '';
    modalCount.textContent = '';

    modalOverlay.classList.add('open');
    document.body.classList.add('modal-open');
    modalOverlay.setAttribute('aria-hidden', 'false');

    updateModalActionState();
  }

  function closeModal() {
    modalOverlay.classList.remove('open');
    document.body.classList.remove('modal-open');
    modalOverlay.setAttribute('aria-hidden', 'true');
    modalCtx = null;
    lastEpisodes = [];
  }
  
  const modalBusy = document.getElementById('modalBusy');

  function setModalBusy(on, hintText = '') {
    if (modalBusy) modalBusy.classList.toggle('on', !!on);

    // optional hint text update
    if (hintText) modalHint.textContent = hintText;

    // disable modal buttons while busy
    if (modalRefresh) modalRefresh.disabled = !!on;
    if (modalSelectAll) modalSelectAll.disabled = !!on;
    if (modalDeleteSelected) modalDeleteSelected.disabled = !!on;
    if (modalDownloadSelected) modalDownloadSelected.disabled = !!on;
  }

  modalClose.addEventListener('click', closeModal);

  modalOverlay.addEventListener('click', (e) => {
    if (e.target === modalOverlay) closeModal();
  });

  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && modalOverlay.classList.contains('open')) closeModal();
  });

  // =========================
  // Helpers
  // =========================
  function setStatus(msg, cls='muted') {
    statusEl.className = 'statusText' + (cls === 'ok' ? ' ok' : cls === 'err' ? ' err' : '');
    statusEl.textContent = msg;
  }

  function setBusy(isBusy) {
    statusWrap.classList.toggle('busy', !!isBusy);

    btnSub.disabled = !!isBusy;
    btnRefresh.disabled = !!isBusy;
    rssEl.disabled = !!isBusy;
    dlEl.disabled = !!isBusy;
    limitEl.disabled = !!isBusy;
  }

  function log(msg, obj) {
    const line = (obj !== undefined)
      ? `${msg} ${JSON.stringify(obj, null, 2)}`
      : msg;

    logEl.textContent += line + "\n";
    logEl.scrollTop = logEl.scrollHeight;
  }

  function esc(s) {
    return String(s ?? '').replace(/[&<>"]/g, c =>
      ({ '&':'&amp;', '<':'&lt;', '>':'&gt;', '"':'&quot;' }[c])
    );
  }

  function placeholderSvgDataUri(label = "Podcast") {
    const text = String(label || "Podcast").slice(0, 18).replace(/[&<>"]/g, '');
    const svg = `
      <svg xmlns="http://www.w3.org/2000/svg" width="112" height="112">
        <defs>
          <linearGradient id="g" x1="0" x2="1" y1="0" y2="1">
            <stop offset="0" stop-color="#1b2a4a"/>
            <stop offset="1" stop-color="#2b174a"/>
          </linearGradient>
        </defs>
        <rect width="112" height="112" rx="18" fill="url(#g)"/>
        <circle cx="84" cy="28" r="10" fill="rgba(125,211,252,.35)"/>
        <circle cx="28" cy="86" r="12" fill="rgba(167,139,250,.28)"/>
        <text x="56" y="62" text-anchor="middle"
              font-family="system-ui, -apple-system, Segoe UI, Roboto, sans-serif"
              font-size="14" fill="rgba(255,255,255,.90)">${text}</text>
      </svg>`;
    return `data:image/svg+xml;charset=utf-8,${encodeURIComponent(svg)}`;
  }

  async function apiGet(path) {
    const r = await fetch(`${API_BASE}${path}`, { cache: 'no-store' });
    const j = await r.json().catch(() => ({}));
    if (!r.ok || j.ok === false) throw new Error(j.error || `HTTP ${r.status}`);
    return j;
  }

  async function apiPost(path, body) {
    const r = await fetch(`${API_BASE}${path}`, {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify(body || {})
    });
    const j = await r.json().catch(() => ({}));
    if (!r.ok || j.ok === false) throw new Error(j.error || `HTTP ${r.status}`);
    return j;
  }

  function mapUrlFromPath(mapJsonPath) {
    const base = String(mapJsonPath || '').split('/').pop();
    return base ? `/podcasts/${base}` : '';
  }

  function canonicalEpisodeIdFromKeyOrUrl(raw) {
    const s = String(raw || '').trim();
    if (!s) return '';

    const idMatch = s.match(/^id:([A-Za-z]+[0-9]+)/);
    if (idMatch) return idMatch[1];

    const nprMatch = s.match(/(NPR[0-9]{6,})/);
    if (nprMatch) return nprMatch[1];

    try {
      const u = new URL(s);
      const last = (u.pathname.split('/').pop() || '').replace(/\.mp3$/i, '');
      if (last) return last;
    } catch (_) {}

    return s;
  }

  function groupEpisodesByCanonicalId(eps) {
    const m = new Map();

    for (const ep of (eps || [])) {
      const key = String(ep.enclosureUrl || ep.link || ep.id || ep.guid || ep.title || '');
      const cid =
        canonicalEpisodeIdFromKeyOrUrl(key) ||
        canonicalEpisodeIdFromKeyOrUrl(ep.enclosure?.url) ||
        canonicalEpisodeIdFromKeyOrUrl(ep.enclosureUrl) ||
        '';

      const bucketKey = cid || key;
      if (!bucketKey) continue;

      const existing = m.get(bucketKey);
      if (!existing) {
        m.set(bucketKey, {
          ...ep,
          _canonicalId: bucketKey,
          _variants: [key].filter(Boolean)
        });
      } else {
        const a = (typeof existing.published === 'number') ? existing.published : 0;
        const b = (typeof ep.published === 'number') ? ep.published : 0;
        if (b > a) existing.published = b;

        if (!existing.date && ep.date) existing.date = ep.date;

        if (key && !existing._variants.includes(key)) existing._variants.push(key);
      }
    }

    return Array.from(m.values());
  }

  function bestDownloadUrl(ep) {
    const candidates = [];
    if (ep.enclosureUrl) candidates.push(String(ep.enclosureUrl));
    if (Array.isArray(ep._variants)) candidates.push(...ep._variants.map(String));

    return candidates.find(s => /^https?:\/\//i.test(s)) || '';
  }

  function formatDate(ep) {
    if (ep.date) return String(ep.date);

    if (typeof ep.published === 'number') {
      const d = new Date(ep.published);
      if (!Number.isNaN(d.getTime())) {
        return d.toLocaleDateString(undefined, { year:'numeric', month:'short', day:'numeric' });
      }
    }

    const raw = ep.pubDate || ep.updated || '';
    if (raw) {
      const d = new Date(raw);
      if (!Number.isNaN(d.getTime())) {
        return d.toLocaleDateString(undefined, { year:'numeric', month:'short', day:'numeric' });
      }
      return String(raw);
    }

    return '';
  }

function updateModalActionState() {
  const checked = Array.from(epList.querySelectorAll('input.epChk:checked'));

  const anyDownloadedChecked = checked.some(
    b => b.dataset.downloaded === '1'
  );

  // Only enable Download Selected if at least one checked item is NOT downloaded
  // AND has a valid enclosure URL we can actually download.
  const anyDownloadableChecked = checked.some(
    b =>
      b.dataset.downloaded !== '1' &&
      /^https?:\/\//i.test(String(b.dataset.url || '').trim())
  );

  modalDeleteSelected.disabled = !anyDownloadedChecked;
  modalDownloadSelected.disabled = !anyDownloadableChecked;
}
  // =========================
  // Episodes UI
  // =========================


function renderEpisodes(eps) {
  epList.innerHTML = '';

  if (!eps || !eps.length) {
    modalHint.textContent = 'No episodes found.';
    modalCount.textContent = '0 episode(s)';
    updateModalActionState();
    return;
  }

  modalHint.textContent = '';
  modalCount.textContent = `${eps.length} episode(s)`;

  for (const ep of eps) {
    const row = document.createElement('div');
    row.className = 'epRow';

    const chk = document.createElement('input');
    chk.type = 'checkbox';
    chk.className = 'epChk';

    // Prefer explicit id; fall back to key "id:xxxx" if needed
    const id =
      String(ep.id || '').trim() ||
      String(ep.key || '').trim().replace(/^id:/i, '');

    const enclosure = String(ep.enclosure || '').trim();
    const title = String(ep.title || '').trim();
    const date = String(ep.date || '').trim();
    const filename = String(ep.filename || '').trim();
    const downloaded = !!ep.downloaded;

    const imageUrl = String(ep.imageUrl || ep.image || '').trim();
chk.dataset.imageUrl = imageUrl;

    chk.dataset.epid = id;
    chk.dataset.url = enclosure;
    chk.dataset.title = title;
    chk.dataset.date = date;
    chk.dataset.downloaded = downloaded ? '1' : '0';
    chk.dataset.image = imageUrl;

    chk.addEventListener('change', updateModalActionState);

    const main = document.createElement('div');
    main.className = 'epMain';

    const t = document.createElement('div');
    t.className = 'epTitle';
    t.textContent = title || '(untitled)';

    const m = document.createElement('div');
    m.className = 'epMeta';
    m.textContent = downloaded
      ? (filename || 'Downloaded')
      : 'Not downloaded';

    if (downloaded) {
      row.classList.add('epDownloaded');
    }

    main.appendChild(t);
    main.appendChild(m);

    const right = document.createElement('div');
    right.className = 'epRight';

    // Date always shows
    const dateEl = document.createElement('div');
    dateEl.className = 'epDate';
    dateEl.textContent = date || '';
    right.appendChild(dateEl);

    // ‚ñ∂Ô∏è Play button only when downloaded AND we have a path to play
    // Prefer ep.mpdPath (best), else fall back to constructing it if filename exists.
    const mpdPath = String(ep.mpdPath || '').trim() ||
                    (filename ? `${String(modalCtx?.mpdPrefix || '').trim()}/${filename}` : '');

    if (downloaded && mpdPath) {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'epPlayBtn';
      btn.title = 'Play';
      btn.setAttribute('aria-label', 'Play episode');
      btn.dataset.file = mpdPath;

      btn.innerHTML = `
        <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
          <path d="M8 5v14l11-7z"></path>
        </svg>
      `;

      right.appendChild(btn);
    }

    row.appendChild(chk);
    row.appendChild(main);
    row.appendChild(right);

    epList.appendChild(row);
  }

  updateModalActionState();
}

// Play button handler (event delegation)
epList.addEventListener('click', async (e) => {
  const btn = e.target.closest('.epPlayBtn');
  if (!btn) return;

  const file = String(btn.dataset.file || '').trim();
  if (!file) return;

  try {
    btn.disabled = true;
    await apiPost('/mpd/play-file', { file });
  } catch (err) {
    console.error('play-file failed:', err);
    alert(`Play failed: ${err?.message || err}`);
  } finally {
    btn.disabled = false;
  }
});

async function loadEpisodes() {
  try {
    if (!modalCtx?.rss) {
      modalHint.textContent = 'Missing rss for this subscription.';
      return;
    }

    setModalBusy(true, 'Loading‚Ä¶');
    epList.innerHTML = '';
    modalCount.textContent = '';
    updateModalActionState();

    const limit = Number(modalCtx.limit || limitEl.value || 50);

    // Fetch merged feed+disk view
    const j = await apiPost('/podcasts/episodes/list', {
      rss: modalCtx.rss,
      limit
    });

    // Helpful debugging (safe to remove later)
    console.log('[episodes/list] rss=', modalCtx.rss, 'limit=', limit);
    console.log('[episodes/list] downloadedCount=', j?.downloadedCount);
    console.log(
      '[episodes/list] sample:',
      (j?.episodes || []).slice(0, 10).map(e => ({
        id: e?.id,
        downloaded: e?.downloaded,
        filename: e?.filename,
        mpdPath: e?.mpdPath,
        title: e?.title
      }))
    );

    const raw = Array.isArray(j?.episodes) ? j.episodes : [];

    const eps = raw.map(ep => {
      const downloaded =
        ep?.downloaded === true ||
        ep?.downloaded === 1 ||
        ep?.downloaded === '1' ||
        ep?.downloaded === 'true';

      // IMPORTANT: mpdPath is what we will POST to /mpd/play-file
      // Prefer ep.mpdPath if the API provides it; otherwise fall back to building it.
      // (If your server always returns mpdPath, this fallback won‚Äôt be used.)
      const mpdPath =
        String(ep?.mpdPath || '').trim() ||
        (modalCtx?.mpdPrefix && ep?.id
          ? `${String(modalCtx.mpdPrefix).replace(/\/$/, '')}/${String(ep.id).trim().toLowerCase()}.mp3`
          : '');

      return {
        ...ep,
        downloaded,
        enclosure: String(ep?.enclosure || ''),
        imageUrl: String(ep?.imageUrl || ep?.image || ''),
        filename: String(ep?.filename || ''),
        date: String(ep?.date || ''),
        mpdPath
      };
    });

    renderEpisodes(eps);
    modalHint.textContent = '';
  } catch (e) {
    modalHint.textContent = `Error loading episodes: ${e?.message || String(e)}`;
  } finally {
    setModalBusy(false);
  }
}

  // Modal Refresh: rebuild map/playlist, no downloads
  modalRefresh.addEventListener('click', async () => {
    if (!modalCtx?.rss) return;

    try {
      modalHint.textContent = 'Refreshing‚Ä¶';

      // If your API has a dedicated "refresh map" endpoint, use it instead.
      // For now, call subscribe with download=0 to rebuild map/m3u coherently.
      const limit = Number(modalCtx.limit || limitEl.value || 50);

      await apiPost('/podcasts/subscribe', {
        rss: modalCtx.rss,
        download: 0,
        limit
      });

      await loadEpisodes();
      modalHint.textContent = '';
    } catch (e) {
      modalHint.textContent = `Refresh failed: ${e.message || String(e)}`;
    }
  });

  modalSelectAll.addEventListener('click', () => {
    const boxes = Array.from(epList.querySelectorAll('input.epChk'));
    if (!boxes.length) return;

    const allChecked = boxes.every(b => b.checked);
    for (const b of boxes) b.checked = !allChecked;

    updateModalActionState();
  });

  modalDownloadSelected.addEventListener('click', async () => {
  if (!modalCtx?.rss) return;

  const checked = Array.from(epList.querySelectorAll('input.epChk:checked'));

  // Only download ones not already downloaded, and that have a feed enclosure URL
  // IMPORTANT: include the episode id so download-one can trust UI's stem
  const jobs = checked
    .filter(b => b.dataset.downloaded !== '1')
    .map(b => ({
      id: String(b.dataset.epid || '').trim().toLowerCase(),
      enclosure: String(b.dataset.url || '').trim(),
      title: String(b.dataset.title || '').trim(),
      date: String(b.dataset.date || '').trim(),
      imageUrl: String(b.dataset.imageUrl || '').trim()   // ‚úÖ add this
    }))
    .filter(j => /^[a-f0-9]{12}$/i.test(j.id) && /^https?:\/\//i.test(j.enclosure));
  
  if (!jobs.length) {
    modalHint.textContent = 'Nothing to download (selected items are already downloaded or missing URL).';
    return;
  }

  const ok = confirm(`Download ${jobs.length} episode(s)?`);
  if (!ok) return;

  try {
    setModalBusy(true, `Downloading ${jobs.length}‚Ä¶`);

    let done = 0;
    for (const j of jobs) {
      await apiPost('/podcasts/download-one', {
        rss: modalCtx.rss,
        id: j.id,
        enclosure: j.enclosure,
        title: j.title,
        date: j.date,
        imageUrl: j.imageUrl || "",
      });
      done++;
      setModalBusy(true, `Downloading‚Ä¶ ${done}/${jobs.length}`);
    }

    // Make the phase change explicit so "stuck" reports are diagnosable.
    setModalBusy(true, 'Refreshing‚Ä¶');
    console.log('[modal] downloads complete -> loadEpisodes()', { rss: modalCtx.rss, count: jobs.length });

    await loadEpisodes();
    modalHint.textContent = '';
  } catch (e) {
    modalHint.textContent = `Download failed: ${e.message || String(e)}`;
  } finally {
    setModalBusy(false);
    updateModalActionState();
  }
});

  modalDeleteSelected.addEventListener('click', async () => {
    if (!modalCtx?.rss) {
      modalHint.textContent = 'Delete failed: Missing rss';
      return;
  }

  const checked = Array.from(epList.querySelectorAll('input.epChk:checked'));

  // Only delete ones that are downloaded
  const episodeUrls = checked
    .filter(b => b.dataset.downloaded === '1')
    .map(b => {
      const k = String(b.dataset.key || '').trim();
      if (k) return k; // preferred: "id:xxxxxxxxxxxx"
      const id = String(b.dataset.epid || '').trim();
      return /^[a-f0-9]{12}$/i.test(id) ? `id:${id.toLowerCase()}` : '';
    })
    .filter(Boolean);

  const uniq = Array.from(new Set(episodeUrls));
  if (!uniq.length) {
    modalHint.textContent = 'Select at least one downloaded episode to delete.';
    return;
  }

  const ok = confirm(`Delete ${uniq.length} episode(s)?`);
  if (!ok) return;

  try {
    setModalBusy(true, `Deleting ${uniq.length}‚Ä¶`);

    await apiPost('/podcasts/episodes/delete', {
      rss: modalCtx.rss,
      episodeUrls: uniq
    });

    await loadEpisodes();
    modalHint.textContent = '';
  } catch (e) {
    modalHint.textContent = `Delete failed: ${e.message || String(e)}`;
  } finally {
    setModalBusy(false);
    updateModalActionState();
  }
});

  // =========================
  // Subscription list UI
  // =========================
  function renderSubscriptions(items) {
    listEl.innerHTML = '';
    const n = (items || []).length;
    subCountEl.textContent = String(n);

    if (!items || !items.length) {
      const empty = document.createElement('div');
      empty.className = 'card';
      empty.innerHTML = `<div class="empty">No subscriptions yet.</div>`;
      listEl.appendChild(empty);
      return;
    }

    for (const p of items) {
      const title = esc(p.title || '(untitled)');
      const rss   = esc(p.rss || '');

      const built = p.lastBuilt ? esc(p.lastBuilt) : '';
      const itemsCount = (typeof p.items === 'number') ? p.items : null;
      const downloadedCount = (typeof p.downloadedCount === 'number') ? p.downloadedCount : null;

      const imgUrlRaw = String(p.imageUrl || '').trim();
      const imgSrc = imgUrlRaw ? esc(imgUrlRaw) : placeholderSvgDataUri(p.title || 'Podcast');

      const card = document.createElement('div');
      card.className = 'card';
      card.innerHTML = `
        <div class="cardHead">
          <img class="thumb" src="${imgSrc}" alt="" loading="lazy" decoding="async" />
          <div class="cardTitleWrap">
            <div class="cardTitle">${title}</div>
            <div class="cardSub">${rss}</div>
          </div>
          <button class="btn btnDanger" data-unsub="${rss}" title="Remove subscription" type="button">Unsubscribe</button>
        </div>

        <div class="cardBody">
          ${built ? `<div class="metaLine"><span class="metaKey">Built</span> <span>${built}</span></div>` : ``}
          ${itemsCount !== null ? `<div class="metaLine"><span class="metaKey">Items</span> <span>${itemsCount}</span></div>` : ``}
          ${downloadedCount !== null ? `<div class="metaLine"><span class="metaKey">Files</span> <span>${downloadedCount}</span></div>` : ``}
        </div>
      `;

      const img = card.querySelector('img.thumb');
      img.addEventListener('error', () => {
        img.src = placeholderSvgDataUri(p.title || 'Podcast');
      }, { once: true });

      card.addEventListener('click', (e) => {
        if (e.target.closest('button')) return;

        openModal({
          title: p.title || '(untitled)',
          rss: p.rss || '',
          imageUrl: String(p.imageUrl || '').trim(),
          mapJson: p.mapJson || '',
          limit: Number(p.limit || 0) || null
        });

        loadEpisodes();
      });

      listEl.appendChild(card);
    }

    listEl.querySelectorAll('button[data-unsub]').forEach(btn => {
      btn.addEventListener('click', async (e) => {
        e.preventDefault();
        e.stopPropagation();

        const rss = btn.getAttribute('data-unsub');
        if (!rss) return;

        setBusy(true);
        logEl.textContent = '';

        try {
          setStatus('Unsubscribing‚Ä¶');
          log('‚Üí POST /podcasts/unsubscribe');
          log('Payload:', { rss });

          const res = await apiPost('/podcasts/unsubscribe', { rss });

          log('‚úì Unsubscribed');
          log('Response:', res);

          setStatus('Unsubscribed.', 'ok');
          await boot();
        } catch (err) {
          log('‚úó Error:', { message: err.message });
          setStatus(`Error: ${err.message}`, 'err');
        } finally {
          setBusy(false);
        }
      });
    });
  }

  async function boot() {
    setBusy(true);
    try {
      setStatus('Refreshing subscription state‚Ä¶');
      logEl.textContent = '';

      log('‚Üí GET /podcasts/refresh');
      const j = await apiGet('/podcasts/refresh');

      renderSubscriptions(j.items || []);
      log('‚úì Loaded subscriptions', { count: (j.items || []).length });

      setStatus(`Loaded ${(j.items || []).length} subscription(s).`, 'muted');
    } catch (e) {
      setStatus(`Error: ${e.message}`, 'err');
      listEl.innerHTML = '';
      log('‚úó Error:', { message: e.message });
    } finally {
      setBusy(false);
    }
  }

  // =========================
  // Hero actions
  // =========================
  btnRefresh.addEventListener('click', boot);

  btnSub.addEventListener('click', async () => {
    const rss = rssEl.value.trim();
    if (!rss) return;

    const download = Number(dlEl.value) || 0;
    const limit    = Number(limitEl.value) || 50;

    logEl.textContent = '';
    setBusy(true);

    const payload = { rss, download, limit };

    try {
      setStatus(`Subscribing (download ${download}, feed scan ${limit})‚Ä¶`, 'muted');

      log('‚Üí POST /podcasts/subscribe');
      log('Payload:', payload);

      const res = await apiPost('/podcasts/subscribe', payload);

      log('‚úì Subscribe complete');
      log('Response:', res);

      // Your API now returns work.sync in the updated flow
      if (res.work?.sync) log('Sync:', res.work.sync);

      setStatus('Subscribed.', 'ok');
      rssEl.value = '';
      await boot();
    } catch (e) {
      log('‚úó Error:', { message: e.message });
      setStatus(`Error: ${e.message}`, 'err');
    } finally {
      setBusy(false);
    }
  });

  boot();
</script>

</html>
