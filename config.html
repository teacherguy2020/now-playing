<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>now-playing Config</title>
  <link rel="stylesheet" href="styles/podcasts.css?v=20260209-2" />
  <link rel="stylesheet" href="styles/podcasts2.css?v=20260209-2" />
  <style>
    .cfgWrap { max-width: 1100px; margin: 0 auto; padding: 10px 16px 36px; }
    .cfgGrid { display:grid; grid-template-columns: repeat(auto-fit,minmax(320px,1fr)); gap:14px; }
    .cfgCard { background: rgba(15,20,26,.7); border:1px solid rgba(255,255,255,.12); border-radius:14px; padding:14px; }
    .cfgCard h3 { margin:0 0 10px; font-size:16px; }
    .cfgField { margin: 10px 0; }
    .cfgField label { display:block; font-size:12px; opacity:.9; margin-bottom:6px; }
    .cfgField input[type=text], .cfgField input[type=password], .cfgField input[type=number] { width:100%; }
    .cfgRow { display:grid; grid-template-columns:1fr 1fr; gap:10px; }
    .cfgActions { display:flex; gap:10px; flex-wrap:wrap; margin-top:12px; }
    .cfgHint { font-size:12px; opacity:.8; }
    input[type="checkbox"] { appearance: auto !important; -webkit-appearance: checkbox !important; }
    pre#out {
      min-height: 120px;
      max-height: 260px;
      overflow:auto;
      background: #000;
      color: #39ff14;
      border: 1px solid rgba(57,255,20,.35);
      border-radius: 10px;
      padding: 12px;
    }
    .miniTableWrap { overflow:auto; border:1px solid rgba(255,255,255,.12); border-radius:10px; }
    table.miniTable { width:100%; border-collapse:collapse; font-size:14px; }
    table.miniTable th, table.miniTable td { padding:8px 10px; border-bottom:1px solid rgba(255,255,255,.08); text-align:left; vertical-align:middle; }
    table.miniTable th { background:rgba(255,255,255,.05); }
    table.miniTable tr:last-child td { border-bottom:none; }
    tr.needsAttention { background: rgba(255, 60, 60, 0.14); }
    .modalBg { position: fixed; inset: 0; background: rgba(0,0,0,.55); display:none; align-items:center; justify-content:center; z-index:9999; }
    .modalBg.show { display:flex; }
    .modalCard { width:min(520px,92vw); background:#0f141a; border:1px solid rgba(255,255,255,.18); border-radius:14px; padding:16px; }
    .modalCard h4 { margin:0 0 8px; }
    .modalActions { display:flex; gap:10px; justify-content:flex-end; margin-top:12px; }
  </style>
</head>
<body>
  <div class="heroRail">
    <div class="heroWrap">
      <nav class="topTabs" aria-label="Main pages">
        <a href="config.html" class="active">Config</a>
        <a href="podcasts.html">Podcasts</a>
        <a href="library-health.html">Library Health</a>
        <a href="queue-wizard.html">Queue Wizard</a>
      </nav>
      <header>
        <div class="brand">
          <h1>now-playing Configuration</h1>
          <div class="sub">Alexa • Notifications • Runtime settings</div>
        </div>

        <div class="pill" title="UI on :8101 → API on :3101">
          <span class="dot" aria-hidden="true"></span>
          API: <span id="apiHint" style="color:rgba(255,255,255,.9)">loading…</span>
        </div>
      </header>

      <section class="panel">
        <div class="controls">
          <div class="cfgWrap">
            <div class="cfgGrid">
              <div class="cfgCard">
                <h3>Auth</h3>
                <div class="cfgField">
                  <label for="trackKey">Track Key (required to save)</label>
                  <input id="trackKey" type="password" placeholder="x-track-key" autocomplete="off" />
                  <input id="trackKeyText" type="text" placeholder="x-track-key" autocomplete="off" style="display:none; margin-top:8px;" />
                </div>
                <div class="cfgField">
                  <label><input id="showTrackKey" type="checkbox" /> Show track key</label>
                </div>
                <div class="cfgHint">Stored in this browser for convenience. Reminder: this same key must be set in Alexa skill/Lambda env.</div>
              </div>

              <div class="cfgCard">
                <h3>Features</h3>
                <div class="cfgField"><label><input id="featurePodcasts" type="checkbox" /> Podcasts</label></div>
                <div class="cfgField"><label><input id="featureRatings" type="checkbox" /> Ratings</label></div>
                <div class="cfgField"><label><input id="featureRadio" type="checkbox" /> Radio per-track artwork</label></div>
              </div>

              <div class="cfgCard" style="grid-column: 1 / -1;">
                <h3>Alexa</h3>
                <div class="cfgRow">
                  <div class="cfgField">
                    <label><input id="alexaEnabled" type="checkbox" /> Enabled</label>
                  </div>
                  <div class="cfgField">
                    <label for="alexaDomain">Public domain</label>
                    <input id="alexaDomain" type="text" placeholder="moode.YOUR-PUBLIC.DOMAIN.com" />
                  </div>
                </div>

                <h4 style="margin:10px 0 6px;">Artist corrections</h4>
                <div class="cfgHint">Use <strong>Promote</strong> below to create corrections from failed requests. Existing corrections are listed here.</div>
                <div id="artistAliasList" class="cfgHint" style="margin-top:8px;"></div>

                <h4 style="margin:12px 0 6px;">Needs correction (auto-captured)</h4>
                <div id="unresolvedArtistList" class="cfgHint"></div>

                <h4 style="margin:12px 0 6px;">Recent Alexa artist inputs</h4>
                <div id="heardArtistList" class="cfgHint"></div>

                <h4 style="margin:16px 0 6px;">Album corrections</h4>
                <div id="albumAliasList" class="cfgHint" style="margin-top:8px;"></div>

                <h4 style="margin:12px 0 6px;">Album needs correction (auto-captured)</h4>
                <div id="unresolvedAlbumList" class="cfgHint"></div>

                <h4 style="margin:12px 0 6px;">Recent Alexa album inputs</h4>
                <div id="heardAlbumList" class="cfgHint"></div>

                <h4 style="margin:16px 0 6px;">Playlist corrections</h4>
                <div id="playlistAliasList" class="cfgHint" style="margin-top:8px;"></div>

                <h4 style="margin:12px 0 6px;">Playlist needs correction (auto-captured)</h4>
                <div id="unresolvedPlaylistList" class="cfgHint"></div>

                <h4 style="margin:12px 0 6px;">Recent Alexa playlist inputs</h4>
                <div id="heardPlaylistList" class="cfgHint"></div>

                <details style="margin-top:8px;">
                  <summary>Advanced JSON view</summary>
                  <textarea id="artistAliasesJson" rows="5" placeholder='{"harry connick junior":"Harry Connick, Jr."}'></textarea>
                </details>
              </div>

              <div class="cfgCard" style="grid-column: 1 / -1;">
                <h3>Track Notifications (Pushover)</h3>
                <div class="cfgField">
                  <label><input id="notifyEnabled" type="checkbox" /> Enabled</label>
                </div>
                <div class="cfgRow">
                  <div class="cfgField">
                    <label for="pollMs">Poll ms</label>
                    <input id="pollMs" type="number" min="1500" />
                  </div>
                  <div class="cfgField">
                    <label for="dedupeMs">Dedupe ms</label>
                    <input id="dedupeMs" type="number" min="5000" />
                  </div>
                </div>
                <div class="cfgField">
                  <label for="alexaMaxAgeMs">Alexa max age ms</label>
                  <input id="alexaMaxAgeMs" type="number" min="30000" />
                </div>
                <div class="cfgRow">
                  <div class="cfgField">
                    <label for="pushoverToken">Pushover token</label>
                    <input id="pushoverToken" type="text" autocomplete="off" />
                  </div>
                  <div class="cfgField">
                    <label for="pushoverUser">Pushover user key</label>
                    <input id="pushoverUser" type="text" autocomplete="off" />
                  </div>
                </div>
              </div>
            </div>

            <div class="cfgCard" style="grid-column: 1 / -1;">
              <h3>Advanced JSON (full config)</h3>
              <div class="cfgHint">Edit full <code>now-playing.config.json</code> directly, then Save Full JSON.</div>
              <div class="cfgField">
                <textarea id="fullJson" style="width:100%; min-height:220px; font-family: ui-monospace, SFMono-Regular, Menlo, monospace;"></textarea>
              </div>
              <div class="cfgActions">
                <button class="btn" id="formatJsonBtn" type="button">Format JSON</button>
                <button class="btn btnPrimary" id="saveFullBtn" type="button">Save Full JSON</button>
              </div>
            </div>

            <div class="cfgActions">
              <button class="btn" id="reloadBtn" type="button">Reload</button>
              <button class="btn btnPrimary" id="saveBtn" type="button">Save</button>
            </div>

            <pre id="out" aria-label="Config response log"></pre>
          </div>
        </div>
      </section>
    </div>
  </div>

  <div id="restartModal" class="modalBg" aria-hidden="true">
    <div class="modalCard">
      <h4>Config saved</h4>
      <div class="cfgHint">Restart API now to apply changes?</div>
      <div class="modalActions">
        <button class="btn" id="modalLaterBtn" type="button">Later</button>
        <button class="btn btnPrimary" id="modalRestartBtn" type="button">Restart API now</button>
      </div>
    </div>
  </div>

<script>
const out = document.getElementById('out');
const HOST = location.hostname.replace(/^www\./, '');
const IS_PUBLIC = (HOST === 'moode.brianwis.com');
const LAN_API_PORT = (location.port === '8101') ? '3101' : '3000';
const API_BASE = IS_PUBLIC ? 'https://moode.brianwis.com' : `${location.protocol}//${location.hostname}:${LAN_API_PORT}`;

document.getElementById('apiHint').textContent = API_BASE.replace(/^https?:\/\//, '');

function log(x){ out.textContent = typeof x === 'string' ? x : JSON.stringify(x, null, 2); }

let artistAliasMap = {};
let albumAliasMap = {};
let playlistAliasMap = {};
let unresolvedArtists = [];
let heardArtists = [];
let unresolvedAlbums = [];
let heardAlbums = [];
let unresolvedPlaylists = [];
let heardPlaylists = [];
function normalizeAliasKey(v){
  return String(v || '').toLowerCase().replace(/\s+/g, ' ').trim();
}
function escapeHtml(s){
  return String(s || '').replace(/[&<>"']/g, (c) => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
}
function renderArtistAliasList(){
  const host = document.getElementById('artistAliasList');
  if (!host) return;
  const rows = Object.entries(artistAliasMap || {}).filter(([k,v]) => String(k).trim() && String(v).trim());
  if (!rows.length) {
    host.innerHTML = '<em>No corrections yet.</em>';
  } else {
    host.innerHTML = `<div class="miniTableWrap"><table class="miniTable"><thead><tr><th>What Alexa heard</th><th>Corrected artist</th><th></th></tr></thead><tbody>${rows
      .sort((a,b)=>a[0].localeCompare(b[0]))
      .map(([heard, corrected]) => `<tr><td><code>${escapeHtml(heard)}</code></td><td><strong>${escapeHtml(corrected)}</strong></td><td><button type="button" class="btn" data-edit-heard="${encodeURIComponent(heard)}" style="padding:2px 8px;">Edit</button> <button type="button" class="btn" data-heard="${encodeURIComponent(heard)}" style="padding:2px 8px; margin-left:4px;">Remove</button></td></tr>`)
      .join('')}</tbody></table></div>`;
  }
  const ta = document.getElementById('artistAliasesJson');
  if (ta) ta.value = JSON.stringify(artistAliasMap || {}, null, 2);
}

function renderAlbumAliasList(){
  const host = document.getElementById('albumAliasList');
  if (!host) return;
  const rows = Object.entries(albumAliasMap || {}).filter(([k,v]) => String(k).trim() && String(v).trim());
  if (!rows.length) {
    host.innerHTML = '<em>No album corrections yet.</em>';
  } else {
    host.innerHTML = `<div class="miniTableWrap"><table class="miniTable"><thead><tr><th>What Alexa heard</th><th>Corrected album</th><th></th></tr></thead><tbody>${rows
      .sort((a,b)=>a[0].localeCompare(b[0]))
      .map(([heard, corrected]) => `<tr><td><code>${escapeHtml(heard)}</code></td><td><strong>${escapeHtml(corrected)}</strong></td><td><button type="button" class="btn" data-edit-heard-album="${encodeURIComponent(heard)}" style="padding:2px 8px;">Edit</button> <button type="button" class="btn" data-heard-album="${encodeURIComponent(heard)}" style="padding:2px 8px; margin-left:4px;">Remove</button></td></tr>`)
      .join('')}</tbody></table></div>`;
  }
}

function renderUnresolvedArtistList(){
  const host = document.getElementById('unresolvedArtistList');
  if (!host) return;
  const rows = Array.isArray(unresolvedArtists) ? unresolvedArtists : [];
  if (!rows.length) {
    host.innerHTML = '<em>No unresolved artist names captured yet.</em>';
    return;
  }
  host.innerHTML = `<div class="miniTableWrap"><table class="miniTable"><thead><tr><th>Needs attention</th><th>Seen</th><th>Last seen</th><th></th></tr></thead><tbody>${rows.map((r, idx) => {
    const heard = String(r?.artist || '').trim();
    const count = Number(r?.count || 1);
    const when = String(r?.updatedAt || r?.createdAt || '');
    const whenShort = when ? new Date(when).toLocaleString() : '';
    return `<tr class="needsAttention"><td><code>${escapeHtml(heard)}</code></td><td>${count}x</td><td>${escapeHtml(whenShort)}</td><td><button type="button" class="btn" data-promote="${idx}" style="padding:2px 8px;">Promote</button> <button type="button" class="btn" data-dismiss="${idx}" style="padding:2px 8px; margin-left:4px;">Dismiss</button></td></tr>`;
  }).join('')}</tbody></table></div>`;
}

function renderHeardArtistList(){
  const host = document.getElementById('heardArtistList');
  if (!host) return;
  const rows = (Array.isArray(heardArtists) ? heardArtists : []).slice(0, 20);
  if (!rows.length) {
    host.innerHTML = '<em>No recent Alexa artist inputs yet.</em>';
    return;
  }
  host.innerHTML = rows.map((r) => {
    const heard = String(r?.artist || '').trim();
    const status = String(r?.status || 'attempt');
    const source = String(r?.source || 'unknown');
    const when = String(r?.at || r?.updatedAt || r?.createdAt || '');
    const whenShort = when ? new Date(when).toLocaleString() : '';
    return `<div style="margin:3px 0;">• <code>${escapeHtml(heard)}</code> <span style="opacity:.8;">[${escapeHtml(status)} · ${escapeHtml(source)}${whenShort ? ' · ' + escapeHtml(whenShort) : ''}]</span></div>`;
  }).join('');
}

function renderUnresolvedAlbumList(){
  const host = document.getElementById('unresolvedAlbumList');
  if (!host) return;
  const rows = Array.isArray(unresolvedAlbums) ? unresolvedAlbums : [];
  if (!rows.length) {
    host.innerHTML = '<em>No unresolved album names captured yet.</em>';
    return;
  }
  host.innerHTML = `<div class="miniTableWrap"><table class="miniTable"><thead><tr><th>Needs attention</th><th>Seen</th><th>Last seen</th><th></th></tr></thead><tbody>${rows.map((r, idx) => {
    const heard = String(r?.album || '').trim();
    const count = Number(r?.count || 1);
    const when = String(r?.updatedAt || r?.createdAt || '');
    const whenShort = when ? new Date(when).toLocaleString() : '';
    return `<tr class="needsAttention"><td><code>${escapeHtml(heard)}</code></td><td>${count}x</td><td>${escapeHtml(whenShort)}</td><td><button type="button" class="btn" data-promote-album="${idx}" style="padding:2px 8px;">Promote</button> <button type="button" class="btn" data-dismiss-album="${idx}" style="padding:2px 8px; margin-left:4px;">Dismiss</button></td></tr>`;
  }).join('')}</tbody></table></div>`;
}

function renderHeardAlbumList(){
  const host = document.getElementById('heardAlbumList');
  if (!host) return;
  const rows = (Array.isArray(heardAlbums) ? heardAlbums : []).slice(0, 20);
  if (!rows.length) {
    host.innerHTML = '<em>No recent Alexa album inputs yet.</em>';
    return;
  }
  host.innerHTML = rows.map((r) => {
    const heard = String(r?.album || '').trim();
    const status = String(r?.status || 'attempt');
    const source = String(r?.source || 'unknown');
    const resolvedTo = String(r?.resolvedTo || '').trim();
    const when = String(r?.at || r?.updatedAt || r?.createdAt || '');
    const whenShort = when ? new Date(when).toLocaleString() : '';
    const resolvedFrag = (resolvedTo && resolvedTo.toLowerCase() !== heard.toLowerCase()) ? ` → <strong>${escapeHtml(resolvedTo)}</strong>` : '';
    return `<div style="margin:3px 0;">• <code>${escapeHtml(heard)}</code>${resolvedFrag} <span style="opacity:.8;">[${escapeHtml(status)} · ${escapeHtml(source)}${whenShort ? ' · ' + escapeHtml(whenShort) : ''}]</span></div>`;
  }).join('');
}

function renderPlaylistAliasList(){
  const host = document.getElementById('playlistAliasList');
  if (!host) return;
  const rows = Object.entries(playlistAliasMap || {}).filter(([k,v]) => String(k).trim() && String(v).trim());
  if (!rows.length) {
    host.innerHTML = '<em>No playlist corrections yet.</em>';
  } else {
    host.innerHTML = `<div class="miniTableWrap"><table class="miniTable"><thead><tr><th>What Alexa heard</th><th>Corrected playlist</th><th></th></tr></thead><tbody>${rows
      .sort((a,b)=>a[0].localeCompare(b[0]))
      .map(([heard, corrected]) => `<tr><td><code>${escapeHtml(heard)}</code></td><td><strong>${escapeHtml(corrected)}</strong></td><td><button type="button" class="btn" data-edit-heard-playlist="${encodeURIComponent(heard)}" style="padding:2px 8px;">Edit</button> <button type="button" class="btn" data-heard-playlist="${encodeURIComponent(heard)}" style="padding:2px 8px; margin-left:4px;">Remove</button></td></tr>`)
      .join('')}</tbody></table></div>`;
  }
}

function renderUnresolvedPlaylistList(){
  const host = document.getElementById('unresolvedPlaylistList');
  if (!host) return;
  const rows = Array.isArray(unresolvedPlaylists) ? unresolvedPlaylists : [];
  if (!rows.length) {
    host.innerHTML = '<em>No unresolved playlist names captured yet.</em>';
    return;
  }
  host.innerHTML = `<div class="miniTableWrap"><table class="miniTable"><thead><tr><th>Needs attention</th><th>Seen</th><th>Last seen</th><th></th></tr></thead><tbody>${rows.map((r, idx) => {
    const heard = String(r?.playlist || '').trim();
    const count = Number(r?.count || 1);
    const when = String(r?.updatedAt || r?.createdAt || '');
    const whenShort = when ? new Date(when).toLocaleString() : '';
    return `<tr class="needsAttention"><td><code>${escapeHtml(heard)}</code></td><td>${count}x</td><td>${escapeHtml(whenShort)}</td><td><button type="button" class="btn" data-promote-playlist="${idx}" style="padding:2px 8px;">Promote</button> <button type="button" class="btn" data-dismiss-playlist="${idx}" style="padding:2px 8px; margin-left:4px;">Dismiss</button></td></tr>`;
  }).join('')}</tbody></table></div>`;
}

function renderHeardPlaylistList(){
  const host = document.getElementById('heardPlaylistList');
  if (!host) return;
  const rows = (Array.isArray(heardPlaylists) ? heardPlaylists : []).slice(0, 20);
  if (!rows.length) {
    host.innerHTML = '<em>No recent Alexa playlist inputs yet.</em>';
    return;
  }
  host.innerHTML = rows.map((r) => {
    const heard = String(r?.playlist || '').trim();
    const status = String(r?.status || 'attempt');
    const source = String(r?.source || 'unknown');
    const resolvedTo = String(r?.resolvedTo || '').trim();
    const when = String(r?.at || r?.updatedAt || r?.createdAt || '');
    const whenShort = when ? new Date(when).toLocaleString() : '';
    const resolvedFrag = (resolvedTo && resolvedTo.toLowerCase() !== heard.toLowerCase()) ? ` → <strong>${escapeHtml(resolvedTo)}</strong>` : '';
    return `<div style="margin:3px 0;">• <code>${escapeHtml(heard)}</code>${resolvedFrag} <span style="opacity:.8;">[${escapeHtml(status)} · ${escapeHtml(source)}${whenShort ? ' · ' + escapeHtml(whenShort) : ''}]</span></div>`;
  }).join('');
}

function loadArtistAliasesFromObject(obj){
  artistAliasMap = (obj && typeof obj === 'object' && !Array.isArray(obj)) ? { ...obj } : {};
  renderArtistAliasList();
}

function getArtistAliasesFromUi(){
  const ta = document.getElementById('artistAliasesJson');
  if (ta) {
    try {
      const parsed = JSON.parse(ta.value || '{}');
      if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {
        artistAliasMap = parsed;
      }
    } catch {}
  }
  const out = {};
  for (const [k,v] of Object.entries(artistAliasMap || {})) {
    const kk = normalizeAliasKey(k);
    const vv = String(v || '').trim();
    if (kk && vv) out[kk] = vv;
  }
  artistAliasMap = out;
  renderArtistAliasList();
  return out;
}

const restartModal = document.getElementById('restartModal');
function showRestartModal(){ if (restartModal) restartModal.classList.add('show'); }
function hideRestartModal(){ if (restartModal) restartModal.classList.remove('show'); }

const TRACK_KEY_STORAGE = 'nowplaying.trackkey';
const tkEl = document.getElementById('trackKey');
const tkTextEl = document.getElementById('trackKeyText');
const showEl = document.getElementById('showTrackKey');

const savedKey = localStorage.getItem(TRACK_KEY_STORAGE) || '';
if (tkEl) tkEl.value = savedKey;
if (tkTextEl) tkTextEl.value = savedKey;

function persistTrackKey(v){ localStorage.setItem(TRACK_KEY_STORAGE, v || ''); }

if (tkEl) tkEl.addEventListener('input', () => {
  if (tkTextEl) tkTextEl.value = tkEl.value || '';
  persistTrackKey(tkEl.value || '');
});
if (tkTextEl) tkTextEl.addEventListener('input', () => {
  if (tkEl) tkEl.value = tkTextEl.value || '';
  persistTrackKey(tkTextEl.value || '');
});

function getTrackKey(){
  if (showEl && showEl.checked) return (tkTextEl?.value || '').trim();
  return (tkEl?.value || '').trim();
}

function applyTrackKeyVisibility(){
  if (!tkEl || !tkTextEl || !showEl) return;
  const val = (tkEl.value || tkTextEl.value || '');
  tkEl.value = val;
  tkTextEl.value = val;
  if (showEl.checked) {
    tkEl.style.display = 'none';
    tkTextEl.style.display = '';
  } else {
    tkTextEl.style.display = 'none';
    tkEl.style.display = '';
  }
}

if (showEl) {
  showEl.addEventListener('change', applyTrackKeyVisibility);
  showEl.addEventListener('click', applyTrackKeyVisibility);
}
applyTrackKeyVisibility();

async function loadCfg(){
  const r = await fetch(`${API_BASE}/config/runtime`, { cache:'no-store' });
  const j = await r.json();
  if (!j.ok) return log(j);

  const c = j.config || {};
  const full = j.fullConfig || {};

  // Preload track key from local cache; fallback to server-provided effective key.
  const localKey = localStorage.getItem(TRACK_KEY_STORAGE) || '';
  const serverKey = String(c.trackKey || '').trim();
  const effectiveKey = localKey || serverKey;
  if (effectiveKey) {
    if (tkEl) tkEl.value = effectiveKey;
    if (tkTextEl) tkTextEl.value = effectiveKey;
    if (!localKey) localStorage.setItem(TRACK_KEY_STORAGE, effectiveKey);
  }

  document.getElementById('alexaEnabled').checked = !!c.alexa?.enabled;
  document.getElementById('alexaDomain').value = c.alexa?.publicDomain || '';

  document.getElementById('notifyEnabled').checked = !!c.notifications?.trackNotify?.enabled;
  document.getElementById('pollMs').value = c.notifications?.trackNotify?.pollMs ?? 3000;
  document.getElementById('dedupeMs').value = c.notifications?.trackNotify?.dedupeMs ?? 15000;
  document.getElementById('alexaMaxAgeMs').value = c.notifications?.trackNotify?.alexaMaxAgeMs ?? 21600000;

  document.getElementById('featurePodcasts').checked = !!c.features?.podcasts;
  document.getElementById('featureRatings').checked = !!c.features?.ratings;
  document.getElementById('featureRadio').checked = !!c.features?.radio;

  loadArtistAliasesFromObject(c.alexa?.artistAliases || {});
  albumAliasMap = (c.alexa?.albumAliases && typeof c.alexa.albumAliases === 'object' && !Array.isArray(c.alexa.albumAliases)) ? { ...c.alexa.albumAliases } : {};
  renderAlbumAliasList();
  playlistAliasMap = (c.alexa?.playlistAliases && typeof c.alexa.playlistAliases === 'object' && !Array.isArray(c.alexa.playlistAliases)) ? { ...c.alexa.playlistAliases } : {};
  renderPlaylistAliasList();
  unresolvedArtists = Array.isArray(c.alexa?.unresolvedArtists) ? c.alexa.unresolvedArtists : [];
  renderUnresolvedArtistList();
  heardArtists = Array.isArray(c.alexa?.heardArtists) ? c.alexa.heardArtists : [];
  renderHeardArtistList();
  unresolvedAlbums = Array.isArray(c.alexa?.unresolvedAlbums) ? c.alexa.unresolvedAlbums : [];
  renderUnresolvedAlbumList();
  heardAlbums = Array.isArray(c.alexa?.heardAlbums) ? c.alexa.heardAlbums : [];
  renderHeardAlbumList();
  unresolvedPlaylists = Array.isArray(c.alexa?.unresolvedPlaylists) ? c.alexa.unresolvedPlaylists : [];
  renderUnresolvedPlaylistList();
  heardPlaylists = Array.isArray(c.alexa?.heardPlaylists) ? c.alexa.heardPlaylists : [];
  renderHeardPlaylistList();

  document.getElementById('pushoverToken').value = c.notifications?.pushover?.token || '';
  document.getElementById('pushoverUser').value = c.notifications?.pushover?.userKey || '';
  document.getElementById('fullJson').value = JSON.stringify(full, null, 2);

  log({ ok:true, configPath:j.configPath, loadedAt:new Date().toISOString() });
}

async function saveArtistCorrectionsOnly(showModal = false){
  const key = getTrackKey();
  if (!key) return log('Track key is required to save.');

  let artistAliases = {};
  try {
    artistAliases = getArtistAliasesFromUi();
  } catch (e) {
    return log('Invalid artist corrections: ' + String(e.message || e));
  }

  const payload = {
    config: {
      alexa: {
        artistAliases,
        albumAliases: albumAliasMap,
        playlistAliases: playlistAliasMap,
        unresolvedArtists,
        heardArtists,
        unresolvedAlbums,
        heardAlbums,
        unresolvedPlaylists,
        heardPlaylists,
      },
    },
  };

  const r = await fetch(`${API_BASE}/config/runtime`, {
    method:'POST',
    headers:{ 'Content-Type':'application/json', 'x-track-key': key },
    body: JSON.stringify(payload),
  });
  const j = await r.json();
  log(j);
  if (showModal && j && j.ok) showRestartModal();
  return j;
}

async function saveCfg(){
  const key = getTrackKey();
  if (!key) return log('Track key is required to save.');

  let artistAliases = {};
  try {
    artistAliases = getArtistAliasesFromUi();
  } catch (e) {
    return log('Invalid artist corrections: ' + String(e.message || e));
  }

  const payload = {
    config: {
      alexa: {
        enabled: document.getElementById('alexaEnabled').checked,
        publicDomain: document.getElementById('alexaDomain').value.trim(),
        artistAliases,
        albumAliases: albumAliasMap,
        playlistAliases: playlistAliasMap,
        unresolvedArtists,
        heardArtists,
        unresolvedAlbums,
        heardAlbums,
        unresolvedPlaylists,
        heardPlaylists,
      },
      notifications: {
        trackNotify: {
          enabled: document.getElementById('notifyEnabled').checked,
          pollMs: Number(document.getElementById('pollMs').value || 3000),
          dedupeMs: Number(document.getElementById('dedupeMs').value || 15000),
          alexaMaxAgeMs: Number(document.getElementById('alexaMaxAgeMs').value || 21600000),
        },
        pushover: {
          token: document.getElementById('pushoverToken').value.trim(),
          userKey: document.getElementById('pushoverUser').value.trim(),
        },
      },
      features: {
        podcasts: document.getElementById('featurePodcasts').checked,
        ratings: document.getElementById('featureRatings').checked,
        radio: document.getElementById('featureRadio').checked,
      },
    },
  };

  const r = await fetch(`${API_BASE}/config/runtime`, {
    method:'POST',
    headers:{ 'Content-Type':'application/json', 'x-track-key': key },
    body: JSON.stringify(payload),
  });

  const j = await r.json();
  log(j);
  if (j && j.ok) showRestartModal();
}

async function saveFullCfg(){
  const key = getTrackKey();
  if (!key) return log('Track key is required to save.');
  let full;
  try {
    full = JSON.parse(document.getElementById('fullJson').value || '{}');
  } catch (e) {
    return log('Invalid JSON: ' + String(e.message || e));
  }

  const r = await fetch(`${API_BASE}/config/runtime`, {
    method:'POST',
    headers:{ 'Content-Type':'application/json', 'x-track-key': key },
    body: JSON.stringify({ fullConfig: full }),
  });
  const j = await r.json();
  log(j);
  if (j && j.ok) showRestartModal();
}

function formatFullJson(){
  try {
    const v = JSON.parse(document.getElementById('fullJson').value || '{}');
    document.getElementById('fullJson').value = JSON.stringify(v, null, 2);
  } catch (e) {
    log('Invalid JSON: ' + String(e.message || e));
  }
}

async function restartApiNow(){
  const key = getTrackKey();
  if (!key) return log('Track key is required to restart API.');
  const r = await fetch(`${API_BASE}/config/restart-api`, {
    method:'POST',
    headers:{ 'Content-Type':'application/json', 'x-track-key': key },
    body: JSON.stringify({}),
  });
  const j = await r.json();
  log(j);
  hideRestartModal();
}

document.getElementById('artistAliasList').addEventListener('click', async (e) => {
  const editBtn = e.target.closest('button[data-edit-heard]');
  if (editBtn) {
    const k = decodeURIComponent(String(editBtn.getAttribute('data-edit-heard') || ''));
    if (!k) return;
    const current = String(artistAliasMap[k] || '').trim();
    const next = window.prompt(`Edit corrected artist for "${k}"`, current);
    if (next == null) return;
    const v = String(next).trim();
    if (!v) {
      delete artistAliasMap[k];
    } else {
      artistAliasMap[k] = v;
    }
    renderArtistAliasList();
    try { await saveArtistCorrectionsOnly(false); } catch (err) { log(String(err)); }
    return;
  }

  const btn = e.target.closest('button[data-heard]');
  if (!btn) return;
  const k = decodeURIComponent(String(btn.getAttribute('data-heard') || ''));
  if (!k) return;
  delete artistAliasMap[k];
  renderArtistAliasList();
  try { await saveArtistCorrectionsOnly(false); } catch (err) { log(String(err)); }
});

document.getElementById('unresolvedArtistList').addEventListener('click', async (e) => {
  const promoteBtn = e.target.closest('button[data-promote]');
  const dismissBtn = e.target.closest('button[data-dismiss]');

  if (promoteBtn) {
    const idx = Number(promoteBtn.getAttribute('data-promote'));
    const row = unresolvedArtists[idx] || {};
    const heardRaw = String(row.artist || '').trim();
    if (!heardRaw) return;
    const suggested = String(artistAliasMap[normalizeAliasKey(heardRaw)] || heardRaw).trim();
    const corrected = window.prompt(`Corrected library name for "${heardRaw}"`, suggested);
    if (!corrected || !String(corrected).trim()) return;
    artistAliasMap[normalizeAliasKey(heardRaw)] = String(corrected).trim();
    unresolvedArtists.splice(idx, 1);
    renderArtistAliasList();
    renderUnresolvedArtistList();
    try { await saveArtistCorrectionsOnly(false); } catch (err) { log(String(err)); }
    return;
  }

  if (dismissBtn) {
    const idx = Number(dismissBtn.getAttribute('data-dismiss'));
    if (!Number.isFinite(idx)) return;
    unresolvedArtists.splice(idx, 1);
    renderUnresolvedArtistList();
    try { await saveArtistCorrectionsOnly(false); } catch (err) { log(String(err)); }
  }
});

document.getElementById('albumAliasList').addEventListener('click', async (e) => {
  const editBtn = e.target.closest('button[data-edit-heard-album]');
  if (editBtn) {
    const k = decodeURIComponent(String(editBtn.getAttribute('data-edit-heard-album') || ''));
    if (!k) return;
    const current = String(albumAliasMap[k] || '').trim();
    const next = window.prompt(`Edit corrected album for "${k}"`, current);
    if (next == null) return;
    const v = String(next).trim();
    if (!v) {
      delete albumAliasMap[k];
    } else {
      albumAliasMap[k] = v;
    }
    renderAlbumAliasList();
    try { await saveArtistCorrectionsOnly(false); } catch (err) { log(String(err)); }
    return;
  }

  const btn = e.target.closest('button[data-heard-album]');
  if (!btn) return;
  const k = decodeURIComponent(String(btn.getAttribute('data-heard-album') || ''));
  if (!k) return;
  delete albumAliasMap[k];
  renderAlbumAliasList();
  try { await saveArtistCorrectionsOnly(false); } catch (err) { log(String(err)); }
});

document.getElementById('unresolvedAlbumList').addEventListener('click', async (e) => {
  const promoteBtn = e.target.closest('button[data-promote-album]');
  const dismissBtn = e.target.closest('button[data-dismiss-album]');

  if (promoteBtn) {
    const idx = Number(promoteBtn.getAttribute('data-promote-album'));
    const row = unresolvedAlbums[idx] || {};
    const heardRaw = String(row.album || '').trim();
    if (!heardRaw) return;
    const suggested = String(albumAliasMap[normalizeAliasKey(heardRaw)] || heardRaw).trim();
    const corrected = window.prompt(`Corrected album name for "${heardRaw}"`, suggested);
    if (!corrected || !String(corrected).trim()) return;
    albumAliasMap[normalizeAliasKey(heardRaw)] = String(corrected).trim();
    unresolvedAlbums.splice(idx, 1);
    renderAlbumAliasList();
    renderUnresolvedAlbumList();
    try { await saveArtistCorrectionsOnly(false); } catch (err) { log(String(err)); }
    return;
  }

  if (dismissBtn) {
    const idx = Number(dismissBtn.getAttribute('data-dismiss-album'));
    if (!Number.isFinite(idx)) return;
    unresolvedAlbums.splice(idx, 1);
    renderUnresolvedAlbumList();
    try { await saveArtistCorrectionsOnly(false); } catch (err) { log(String(err)); }
  }
});

document.getElementById('playlistAliasList').addEventListener('click', async (e) => {
  const editBtn = e.target.closest('button[data-edit-heard-playlist]');
  if (editBtn) {
    const k = decodeURIComponent(String(editBtn.getAttribute('data-edit-heard-playlist') || ''));
    if (!k) return;
    const current = String(playlistAliasMap[k] || '').trim();
    const next = window.prompt(`Edit corrected playlist for "${k}"`, current);
    if (next == null) return;
    const v = String(next).trim();
    if (!v) delete playlistAliasMap[k]; else playlistAliasMap[k] = v;
    renderPlaylistAliasList();
    try { await saveArtistCorrectionsOnly(false); } catch (err) { log(String(err)); }
    return;
  }

  const btn = e.target.closest('button[data-heard-playlist]');
  if (!btn) return;
  const k = decodeURIComponent(String(btn.getAttribute('data-heard-playlist') || ''));
  if (!k) return;
  delete playlistAliasMap[k];
  renderPlaylistAliasList();
  try { await saveArtistCorrectionsOnly(false); } catch (err) { log(String(err)); }
});

document.getElementById('unresolvedPlaylistList').addEventListener('click', async (e) => {
  const promoteBtn = e.target.closest('button[data-promote-playlist]');
  const dismissBtn = e.target.closest('button[data-dismiss-playlist]');

  if (promoteBtn) {
    const idx = Number(promoteBtn.getAttribute('data-promote-playlist'));
    const row = unresolvedPlaylists[idx] || {};
    const heardRaw = String(row.playlist || '').trim();
    if (!heardRaw) return;
    const suggested = String(playlistAliasMap[normalizeAliasKey(heardRaw)] || heardRaw).trim();
    const corrected = window.prompt(`Corrected playlist name for "${heardRaw}"`, suggested);
    if (!corrected || !String(corrected).trim()) return;
    playlistAliasMap[normalizeAliasKey(heardRaw)] = String(corrected).trim();
    unresolvedPlaylists.splice(idx, 1);
    renderPlaylistAliasList();
    renderUnresolvedPlaylistList();
    try { await saveArtistCorrectionsOnly(false); } catch (err) { log(String(err)); }
    return;
  }

  if (dismissBtn) {
    const idx = Number(dismissBtn.getAttribute('data-dismiss-playlist'));
    if (!Number.isFinite(idx)) return;
    unresolvedPlaylists.splice(idx, 1);
    renderUnresolvedPlaylistList();
    try { await saveArtistCorrectionsOnly(false); } catch (err) { log(String(err)); }
  }
});

document.getElementById('artistAliasesJson').addEventListener('input', () => {
  try {
    const parsed = JSON.parse(document.getElementById('artistAliasesJson').value || '{}');
    if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {
      artistAliasMap = parsed;
      renderArtistAliasList();
    }
  } catch {}
});

document.getElementById('reloadBtn').onclick = () => loadCfg().catch(e => log(String(e)));
document.getElementById('saveBtn').onclick = () => saveCfg().catch(e => log(String(e)));
document.getElementById('saveFullBtn').onclick = () => saveFullCfg().catch(e => log(String(e)));
document.getElementById('formatJsonBtn').onclick = () => formatFullJson();
document.getElementById('modalLaterBtn').onclick = () => hideRestartModal();
document.getElementById('modalRestartBtn').onclick = () => restartApiNow().catch(e => log(String(e)));
loadCfg().catch(e => log(String(e)));
</script>
</body>
</html>
