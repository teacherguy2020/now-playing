<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>now-playing Config</title>
  <link rel="stylesheet" href="styles/podcasts.css?v=20260209-2" />
  <link rel="stylesheet" href="styles/podcasts2.css?v=20260209-2" />
  <style>
    .cfgWrap { max-width: 1100px; margin: 0 auto; padding: 10px 16px 36px; }
    .cfgGrid { display:grid; grid-template-columns: repeat(auto-fit,minmax(320px,1fr)); gap:14px; }
    .cfgCard { background: rgba(15,20,26,.7); border:1px solid rgba(255,255,255,.12); border-radius:14px; padding:14px; }
.cfgCard.blocked { opacity:.45; filter:grayscale(.35); }
.cfgCard.blocked * { pointer-events:none !important; }
    .cfgCard h3 { margin:0 0 10px; font-size:16px; }
    .cfgField { margin: 10px 0; }
    .cfgField label { display:block; font-size:12px; opacity:.9; margin-bottom:6px; }
    .cfgField input[type=text], .cfgField input[type=password], .cfgField input[type=number] { width:100%; }
    .cfgRow { display:grid; grid-template-columns:1fr 1fr; gap:10px; }
    .cfgActions { display:flex; gap:10px; flex-wrap:wrap; margin-top:12px; }
    .cfgHint { font-size:12px; opacity:.8; }
    input[type="checkbox"] { appearance: auto !important; -webkit-appearance: checkbox !important; }
    pre#out {
      min-height: 120px;
      max-height: 260px;
      overflow:auto;
      background: #000;
      color: #39ff14;
      border: 1px solid rgba(57,255,20,.35);
      border-radius: 10px;
      padding: 12px;
    }
    .miniTableWrap { overflow:auto; border:1px solid rgba(255,255,255,.12); border-radius:10px; }
    table.miniTable { width:100%; border-collapse:collapse; font-size:14px; }
    table.miniTable th, table.miniTable td { padding:8px 10px; border-bottom:1px solid rgba(255,255,255,.08); text-align:left; vertical-align:middle; }
    table.miniTable th { background:rgba(255,255,255,.05); }
    table.miniTable tr:last-child td { border-bottom:none; }
    tr.needsAttention { background: rgba(255, 60, 60, 0.14); }
    .modalBg { position: fixed; inset: 0; background: rgba(0,0,0,.55); display:none; align-items:center; justify-content:center; z-index:9999; }
    .modalBg.show { display:flex; }
    .modalCard { width:min(520px,92vw); background:#0f141a; border:1px solid rgba(255,255,255,.18); border-radius:14px; padding:16px; }
    .modalCard h4 { margin:0 0 8px; }
    .modalActions { display:flex; gap:10px; justify-content:flex-end; margin-top:12px; }
  </style>
</head>
<body>
  <div class="heroRail">
    <div class="heroWrap">
      <div style="display:flex;gap:10px;justify-content:space-between;align-items:flex-end;flex-wrap:wrap;">
        <nav class="topTabs" aria-label="Main pages" style="margin-bottom:0;">
          <a href="config.html" class="active">Config</a>
          <a href="diagnostics.html">Diagnostics</a>
          <a href="library-health.html">Library Health</a>
          <a href="queue-wizard.html">Queue Wizard</a>
          <a href="podcasts.html">Podcasts</a>
        </nav>

        <div style="display:flex;gap:8px;flex-wrap:wrap;">
          <div class="pill" id="apiPill" title="Active API endpoint">
            <span class="dot" aria-hidden="true"></span>
            API: <span id="apiHint" style="color:rgba(255,255,255,.9)">loading…</span>
          </div>
          <div class="pill" id="webPill" title="Active web UI endpoint">
            <span class="dot" aria-hidden="true"></span>
            Web: <span id="webHint" style="color:rgba(255,255,255,.9)">loading…</span>
          </div>
          <div class="pill" id="alexaPill" title="Alexa public domain health">
            <span class="dot" aria-hidden="true"></span>
            Alexa: <span id="alexaHint" style="color:rgba(255,255,255,.9)">unknown</span>
          </div>
        </div>
      </div>
      <header>
        <div class="brand">
          <h1>now-playing Configuration</h1>
          <div class="sub">Alexa • Notifications • Runtime settings</div>
        </div>
      </header>

      <section class="panel">
        <div class="controls">
          <div class="cfgWrap">
            <div class="cfgGrid">
              <div class="cfgCard" id="networkCard">
                <h3>Network & Runtime</h3>
                <div class="cfgHint" style="margin-bottom:8px;"><strong>Step 1:</strong> Fill this card, then click <strong>Check SSH + Paths</strong> to unlock the other modules.</div>
                <div class="cfgRow">
                  <div class="cfgField">
                    <label for="apiPort">API port</label>
                    <input id="apiPort" type="number" min="1" max="65535" placeholder="ex. 3101" />
                  </div>
                  <div class="cfgField">
                    <label for="uiPort">UI port</label>
                    <input id="uiPort" type="number" min="1" max="65535" placeholder="ex. 8101" />
                  </div>
                </div>
                <div class="cfgHint">Defaults are API <code>3101</code>, UI <code>8101</code>, MPD port <code>6600</code>, and music library root <code>/var/lib/mpd/music</code>. Host fields are auto-prefilled from this page host and <code>moode.local</code> when possible.</div>
                <div class="cfgField">
                  <label for="apiNodeIp">IP of Webserver and API host</label>
                  <input id="apiNodeIp" type="text" placeholder="ex. 10.0.0.233" />
                  <div class="cfgHint" id="apiNodeIpHint"></div>
                </div>
                <div class="cfgRow">
                  <div class="cfgField">
                    <label for="mpdHost">MPD host</label>
                    <input id="mpdHost" type="text" placeholder="ex. moode.local" />
                    <div class="cfgHint" id="mpdHostHint"></div>
                  </div>
                  <div class="cfgField">
                    <label for="mpdPort">MPD port</label>
                    <input id="mpdPort" type="number" min="1" max="65535" />
                    <div class="cfgHint" id="mpdPortHint"></div>
                  </div>
                </div>
                <div class="cfgRow">
                  <div class="cfgField">
                    <label for="moodeSshHost">moOde SSH host (optional override)</label>
                    <input id="moodeSshHost" type="text" placeholder="defaults to MPD host" />
                  </div>
                  <div class="cfgField">
                    <label for="moodeSshUser">moOde SSH user</label>
                    <input id="moodeSshUser" type="text" placeholder="moode" />
                  </div>
                </div>
                <details style="margin-top:6px;">
                  <summary>SSH key setup help (one-time)</summary>
                  <div class="cfgHint" style="margin-top:8px;">Run on your API host (web/API machine):</div>
                  <pre id="sshSetupCmds" style="white-space:pre-wrap;margin:6px 0 0;"></pre>
                  <div class="cfgHint" style="margin-top:6px;">If sudo check fails, update sudoers on moOde for the configured SSH user (minimum required commands).</div>
                </details>
                <div style="display:none" id="runtimeCheckStatusOld"></div>
                <div style="display:none" id="runtimeCheckDetailsOld"></div>
                <div class="cfgField">
                  <label for="moodeBaseUrl">moOde base URL (optional override)</label>
                  <input id="moodeBaseUrl" type="text" placeholder="ex. http://10.0.0.254" />
                  <div class="cfgHint">Leave blank to derive from SSH/MPD host.</div>
                </div>
                <div class="cfgField">
                  <label for="configTrackKey">Track Key</label>
                  <input id="configTrackKey" type="text" autocomplete="off" placeholder="Use a unique secret key" />
                  <div class="cfgHint">Create a unique key used to protect config and maintenance endpoints (sent as <code>x-track-key</code>).</div>
                </div>
                <div class="cfgField">
                  <label for="pathMusicLibraryRoot">Music library root</label>
                  <input id="pathMusicLibraryRoot" type="text" placeholder="ex. /var/lib/mpd/music" />
                </div>
                <div class="cfgField">
                  <label for="pathMoodeUsbMount">1) Path on moOde (media mount)</label>
                  <input id="pathMoodeUsbMount" type="text" placeholder="ex. /media/NAMEOFYOURDRIVE" />
                </div>
                <div class="cfgHint">Typing in (1) auto-fills (2) and (3).</div>
                <div class="cfgField">
                  <label for="pathPiMountBase">2) Path on API host (mount base)</label>
                  <input id="pathPiMountBase" type="text" placeholder="ex. /mnt/NAMEOFYOURDRIVE" />
                </div>
                <div class="cfgField">
                  <label for="pathPodcastRoot">3) Podcast root on API host</label>
                  <input id="pathPodcastRoot" type="text" placeholder="ex. /mnt/NAMEOFYOURDRIVE/Podcasts" />
                </div>
                <div class="cfgActions" style="margin-top:6px;">
                  <button class="btn" id="checkRuntimeBtn" type="button">Check SSH + Paths</button>
                </div>
                <div class="cfgHint" id="runtimeCheckStatus" style="margin-top:6px;"></div>
                <div id="runtimeCheckDetails" class="cfgHint" style="margin-top:6px;"></div>
              </div>

              <div class="cfgCard gateCard">
                <h3>Podcasts</h3>
                <div class="cfgField"><label><input id="featurePodcasts" type="checkbox" /> Enabled</label></div>
                <div class="cfgHint">Enable podcast pages and background download/subscription tools.</div>
              </div>

              <div class="cfgCard gateCard">
                <h3>Radio Artwork</h3>
                <div class="cfgField"><label><input id="featureRadio" type="checkbox" /> Enabled</label></div>
                <div class="cfgHint">Enable radio per-track artwork behavior in now-playing flows.</div>
              </div>

              <div class="cfgCard gateCard" id="lastfmCard">
                <h3>Last.fm (Vibe)</h3>
                <div class="cfgField"><label><input id="featureLastfm" type="checkbox" /> Enabled</label></div>
                <div class="cfgField">
                  <label for="lastfmApiKey">Last.fm API key</label>
                  <input id="lastfmApiKey" type="password" placeholder="Enter Last.fm API key" autocomplete="off" />
                </div>
                <div class="cfgHint">When enabled/configured, Vibe tools are available in Queue Wizard.</div>
              </div>

              <div class="cfgCard gateCard" id="alexaCard" style="grid-column: 1 / -1;">
                <h3>Alexa</h3>
                <div class="cfgRow">
                  <div class="cfgField">
                    <label><input id="featureAlexaSkill" type="checkbox" /> Enabled</label>
                  </div>
                  <div class="cfgField">
                    <label for="alexaDomain">Public domain</label>
                    <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
                      <input id="alexaDomain" type="text" placeholder="moode.YOUR-PUBLIC.DOMAIN.com" />
                      <button class="btn" id="checkAlexaDomainBtn" type="button">Check domain</button>
                    </div>
                    <div class="cfgHint" id="alexaDomainCheckStatus"></div>
                  </div>
                </div>

                <h4 style="margin:10px 0 6px;">Artist corrections</h4>
                <div class="cfgHint">Use <strong>Promote</strong> below to create corrections from failed requests. Existing corrections are listed here.</div>
                <div id="artistAliasList" class="cfgHint" style="margin-top:8px;"></div>

                <h4 style="margin:12px 0 6px;">Needs correction (auto-captured)</h4>
                <div id="unresolvedArtistList" class="cfgHint"></div>

                <h4 style="margin:12px 0 6px;">Recent Alexa artist inputs</h4>
                <div id="heardArtistList" class="cfgHint"></div>

                <h4 style="margin:16px 0 6px;">Album corrections</h4>
                <div id="albumAliasList" class="cfgHint" style="margin-top:8px;"></div>

                <h4 style="margin:12px 0 6px;">Album needs correction (auto-captured)</h4>
                <div id="unresolvedAlbumList" class="cfgHint"></div>

                <h4 style="margin:12px 0 6px;">Recent Alexa album inputs</h4>
                <div id="heardAlbumList" class="cfgHint"></div>

                <h4 style="margin:16px 0 6px;">Playlist corrections</h4>
                <div id="playlistAliasList" class="cfgHint" style="margin-top:8px;"></div>

                <h4 style="margin:12px 0 6px;">Playlist needs correction (auto-captured)</h4>
                <div id="unresolvedPlaylistList" class="cfgHint"></div>

                <h4 style="margin:12px 0 6px;">Recent Alexa playlist inputs</h4>
                <div id="heardPlaylistList" class="cfgHint"></div>

                <details style="margin-top:8px;">
                  <summary>Advanced JSON view</summary>
                  <textarea id="artistAliasesJson" rows="5" placeholder='{"harry connick junior":"Harry Connick, Jr."}'></textarea>
                </details>
              </div>

              <div class="cfgCard gateCard" id="ratingsCard" style="grid-column: 1 / -1;">
                <h3>Ratings Setup</h3>
                <div class="cfgField"><label><input id="featureRatings" type="checkbox" /> Enabled</label></div>
                <div class="cfgHint">When Ratings is enabled, verify MPD sticker DB and keep backups before updates.</div>
                <div class="cfgActions" style="margin-top:10px;">
                  <button class="btn" id="checkRatingsDbBtn" type="button">Check Ratings DB</button>
                  <button class="btn" id="backupRatingsDbBtn" type="button">Backup Ratings DB</button>
                </div>
                <div class="cfgActions" style="margin-top:8px; align-items:center;">
                  <label style="display:flex;align-items:center;gap:8px;">Restore backup
                    <select id="ratingsBackupSelect" style="min-width:280px"></select>
                  </label>
                  <button class="btn" id="restoreRatingsDbBtn" type="button">Restore Selected Backup</button>
                </div>
                <div class="cfgHint" id="ratingsDbStatus" style="margin-top:8px;"></div>
              </div>

              <div class="cfgCard gateCard" id="pushoverCard" style="grid-column: 1 / -1;">
                <h3>Track Notifications (Pushover)</h3>
                <div class="cfgField"><label><input id="featurePushover" type="checkbox" /> Enabled</label></div>
                <div class="cfgField">
                  <label><input id="notifyEnabled" type="checkbox" /> Track polling active</label>
                </div>
                <div class="cfgRow">
                  <div class="cfgField">
                    <label for="pollMs">Poll ms</label>
                    <input id="pollMs" type="number" min="1500" />
                  </div>
                  <div class="cfgField">
                    <label for="dedupeMs">Dedupe ms</label>
                    <input id="dedupeMs" type="number" min="5000" />
                  </div>
                </div>
                <div class="cfgField">
                  <label for="alexaMaxAgeMs">Alexa max age ms</label>
                  <input id="alexaMaxAgeMs" type="number" min="30000" />
                </div>
                <div class="cfgRow">
                  <div class="cfgField">
                    <label for="pushoverToken">Pushover token</label>
                    <input id="pushoverToken" type="text" autocomplete="off" />
                  </div>
                  <div class="cfgField">
                    <label for="pushoverUser">Pushover user key</label>
                    <input id="pushoverUser" type="text" autocomplete="off" />
                  </div>
                </div>
              </div>
            </div>

            <div class="cfgCard" style="grid-column: 1 / -1;">
              <details id="advancedJsonDetails">
                <summary><strong>Advanced JSON (full config)</strong></summary>
                <div class="cfgHint" style="margin-top:8px;">Edit full <code>now-playing.config.json</code> directly, then Save Full JSON.</div>
                <div class="cfgField">
                  <textarea id="fullJson" style="width:100%; min-height:220px; font-family: ui-monospace, SFMono-Regular, Menlo, monospace;"></textarea>
                </div>
                <div class="cfgActions">
                  <button class="btn" id="formatJsonBtn" type="button">Format JSON</button>
                  <button class="btn btnPrimary" id="saveFullBtn" type="button">Save Full JSON</button>
                </div>
              </details>
            </div>

            <div class="cfgActions">
              <button class="btn" id="reloadBtn" type="button">Reload</button>
              <button class="btn btnPrimary" id="saveBtn" type="button">Save</button>
            </div>
            <div class="cfgHint" style="margin-top:4px;">
              <strong>Reload</strong> pulls the latest config from disk and discards unsaved edits on this page. 
              <strong>Save</strong> writes the form values to config JSON.
            </div>

            <pre id="out" aria-label="Config response log"></pre>
          </div>
        </div>
      </section>
    </div>
  </div>

  <div id="restartModal" class="modalBg" aria-hidden="true">
    <div class="modalCard">
      <h4>Config saved</h4>
      <div class="cfgHint">Restart services now to apply changes?</div>
      <div class="modalActions">
        <button class="btn" id="modalLaterBtn" type="button">Later</button>
        <button class="btn btnPrimary" id="modalRestartBtn" type="button">Restart services now</button>
      </div>
    </div>
  </div>

<script>
const out = document.getElementById('out');
const HOST = location.hostname.replace(/^www\./, '');
const IS_PUBLIC = (HOST === 'moode.brianwis.com');
const LAN_API_PORT = (location.port === '8101') ? '3101' : '3000';
const API_BASE = IS_PUBLIC ? 'https://moode.brianwis.com' : `${location.protocol}//${location.hostname}:${LAN_API_PORT}`;

document.getElementById('apiHint').textContent = API_BASE.replace(/^https?:\/\//, '');
setPillState('apiPill', 'neutral');
const webHintEl = document.getElementById('webHint');
if (webHintEl) webHintEl.textContent = `${location.hostname}:${(location.port === '8101' ? '8101' : (location.port || '8101'))}`;
setPillState('webPill', 'neutral');
const alexaHintEl = document.getElementById('alexaHint');
if (alexaHintEl) alexaHintEl.textContent = 'unknown';
setPillState('alexaPill', 'neutral');

function log(x){ out.textContent = typeof x === 'string' ? x : JSON.stringify(x, null, 2); }

function applyInitialNetworkPrefills(){
  const host = location.hostname || '127.0.0.1';

  const apiPortEl = document.getElementById('apiPort');
  const uiPortEl = document.getElementById('uiPort');
  const apiNodeIpEl = document.getElementById('apiNodeIp');
  const mpdHostEl = document.getElementById('mpdHost');
  const mpdPortEl = document.getElementById('mpdPort');
  const musicRootEl = document.getElementById('pathMusicLibraryRoot');

  const apiNodeIpHint = document.getElementById('apiNodeIpHint');
  const mpdHostHint = document.getElementById('mpdHostHint');
  const mpdPortHint = document.getElementById('mpdPortHint');

  if (apiPortEl && !String(apiPortEl.value || '').trim()) apiPortEl.value = '3101';
  if (uiPortEl && !String(uiPortEl.value || '').trim()) uiPortEl.value = '8101';
  if (apiNodeIpEl && !String(apiNodeIpEl.value || '').trim()) apiNodeIpEl.value = host;
  if (mpdHostEl && !String(mpdHostEl.value || '').trim()) mpdHostEl.value = 'moode.local';
  if (mpdPortEl && !String(mpdPortEl.value || '').trim()) mpdPortEl.value = '6600';
  if (musicRootEl && !String(musicRootEl.value || '').trim()) musicRootEl.value = '/var/lib/mpd/music';

  if (apiNodeIpHint) apiNodeIpHint.textContent = `Auto-defaulted from page host: ${host}`;
  if (mpdHostHint) mpdHostHint.textContent = 'Auto-defaulted: moode.local (will resolve to IP when possible)';
  if (mpdPortHint) mpdPortHint.textContent = 'Default is 6600 (current)';
}

async function resolveMpdHostIfLocal(){
  const key = getTrackKey();
  const mpdHostEl = document.getElementById('mpdHost');
  const sshHostEl = document.getElementById('moodeSshHost');
  const hintEl = document.getElementById('mpdHostHint');
  if (!mpdHostEl) return;
  const cur = String(mpdHostEl.value || '').trim().toLowerCase();
  if (cur !== 'moode.local') return;
  if (!key) return;
  try {
    const r = await fetch(`${API_BASE}/config/runtime/resolve-host`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'x-track-key': key },
      body: JSON.stringify({ host: 'moode.local' }),
    });
    const j = await r.json().catch(() => ({}));
    if (!r.ok || !j?.ok || !j?.address) return;
    const ip = String(j.address || '').trim();
    if (!ip) return;
    mpdHostEl.value = ip;
    if (sshHostEl && !String(sshHostEl.value || '').trim()) sshHostEl.value = ip;
    if (hintEl) hintEl.textContent = `Resolved moode.local → ${ip}`;
  } catch (_) {}
}

let artistAliasMap = {};
let albumAliasMap = {};
let playlistAliasMap = {};
let unresolvedArtists = [];
let heardArtists = [];
let unresolvedAlbums = [];
let heardAlbums = [];
let unresolvedPlaylists = [];
let heardPlaylists = [];
let loadedNodes = [];
function normalizeAliasKey(v){
  return String(v || '').toLowerCase().replace(/\s+/g, ' ').trim();
}
function escapeHtml(s){
  return String(s || '').replace(/[&<>"']/g, (c) => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
}
function renderArtistAliasList(){
  const host = document.getElementById('artistAliasList');
  if (!host) return;
  const rows = Object.entries(artistAliasMap || {}).filter(([k,v]) => String(k).trim() && String(v).trim());
  if (!rows.length) {
    host.innerHTML = '<em>No corrections yet.</em>';
  } else {
    host.innerHTML = `<div class="miniTableWrap"><table class="miniTable"><thead><tr><th>What Alexa heard</th><th>Corrected artist</th><th></th></tr></thead><tbody>${rows
      .sort((a,b)=>a[0].localeCompare(b[0]))
      .map(([heard, corrected]) => `<tr><td><code>${escapeHtml(heard)}</code></td><td><strong>${escapeHtml(corrected)}</strong></td><td><button type="button" class="btn" data-edit-heard="${encodeURIComponent(heard)}" style="padding:2px 8px;">Edit</button> <button type="button" class="btn" data-heard="${encodeURIComponent(heard)}" style="padding:2px 8px; margin-left:4px;">Remove</button></td></tr>`)
      .join('')}</tbody></table></div>`;
  }
  const ta = document.getElementById('artistAliasesJson');
  if (ta) ta.value = JSON.stringify(artistAliasMap || {}, null, 2);
}

function renderAlbumAliasList(){
  const host = document.getElementById('albumAliasList');
  if (!host) return;
  const rows = Object.entries(albumAliasMap || {}).filter(([k,v]) => String(k).trim() && String(v).trim());
  if (!rows.length) {
    host.innerHTML = '<em>No album corrections yet.</em>';
  } else {
    host.innerHTML = `<div class="miniTableWrap"><table class="miniTable"><thead><tr><th>What Alexa heard</th><th>Corrected album</th><th></th></tr></thead><tbody>${rows
      .sort((a,b)=>a[0].localeCompare(b[0]))
      .map(([heard, corrected]) => `<tr><td><code>${escapeHtml(heard)}</code></td><td><strong>${escapeHtml(corrected)}</strong></td><td><button type="button" class="btn" data-edit-heard-album="${encodeURIComponent(heard)}" style="padding:2px 8px;">Edit</button> <button type="button" class="btn" data-heard-album="${encodeURIComponent(heard)}" style="padding:2px 8px; margin-left:4px;">Remove</button></td></tr>`)
      .join('')}</tbody></table></div>`;
  }
}

function renderUnresolvedArtistList(){
  const host = document.getElementById('unresolvedArtistList');
  if (!host) return;
  const rows = Array.isArray(unresolvedArtists) ? unresolvedArtists : [];
  if (!rows.length) {
    host.innerHTML = '<em>No unresolved artist names captured yet.</em>';
    return;
  }
  host.innerHTML = `<div class="miniTableWrap"><table class="miniTable"><thead><tr><th>Needs attention</th><th>Seen</th><th>Last seen</th><th></th></tr></thead><tbody>${rows.map((r, idx) => {
    const heard = String(r?.artist || '').trim();
    const count = Number(r?.count || 1);
    const when = String(r?.updatedAt || r?.createdAt || '');
    const whenShort = when ? new Date(when).toLocaleString() : '';
    return `<tr class="needsAttention"><td><code>${escapeHtml(heard)}</code></td><td>${count}x</td><td>${escapeHtml(whenShort)}</td><td><button type="button" class="btn" data-promote="${idx}" style="padding:2px 8px;">Fix</button> <button type="button" class="btn" data-dismiss="${idx}" style="padding:2px 8px; margin-left:4px;">Ignore</button></td></tr>`;
  }).join('')}</tbody></table></div>`;
}

function renderHeardArtistList(){
  const host = document.getElementById('heardArtistList');
  if (!host) return;
  const rows = (Array.isArray(heardArtists) ? heardArtists : []).slice(0, 20);
  if (!rows.length) {
    host.innerHTML = '<em>No recent Alexa artist inputs yet.</em>';
    return;
  }
  host.innerHTML = rows.map((r) => {
    const heard = String(r?.artist || '').trim();
    const status = String(r?.status || 'attempt');
    const source = String(r?.source || 'unknown');
    const when = String(r?.at || r?.updatedAt || r?.createdAt || '');
    const whenShort = when ? new Date(when).toLocaleString() : '';
    return `<div style="margin:3px 0;">• <code>${escapeHtml(heard)}</code> <span style="opacity:.8;">[${escapeHtml(status)} · ${escapeHtml(source)}${whenShort ? ' · ' + escapeHtml(whenShort) : ''}]</span></div>`;
  }).join('');
}

function renderUnresolvedAlbumList(){
  const host = document.getElementById('unresolvedAlbumList');
  if (!host) return;
  const rows = Array.isArray(unresolvedAlbums) ? unresolvedAlbums : [];
  if (!rows.length) {
    host.innerHTML = '<em>No unresolved album names captured yet.</em>';
    return;
  }
  host.innerHTML = `<div class="miniTableWrap"><table class="miniTable"><thead><tr><th>Needs attention</th><th>Seen</th><th>Last seen</th><th></th></tr></thead><tbody>${rows.map((r, idx) => {
    const heard = String(r?.album || '').trim();
    const count = Number(r?.count || 1);
    const when = String(r?.updatedAt || r?.createdAt || '');
    const whenShort = when ? new Date(when).toLocaleString() : '';
    return `<tr class="needsAttention"><td><code>${escapeHtml(heard)}</code></td><td>${count}x</td><td>${escapeHtml(whenShort)}</td><td><button type="button" class="btn" data-promote-album="${idx}" style="padding:2px 8px;">Promote</button> <button type="button" class="btn" data-dismiss-album="${idx}" style="padding:2px 8px; margin-left:4px;">Dismiss</button></td></tr>`;
  }).join('')}</tbody></table></div>`;
}

function renderHeardAlbumList(){
  const host = document.getElementById('heardAlbumList');
  if (!host) return;
  const rows = (Array.isArray(heardAlbums) ? heardAlbums : []).slice(0, 20);
  if (!rows.length) {
    host.innerHTML = '<em>No recent Alexa album inputs yet.</em>';
    return;
  }
  host.innerHTML = rows.map((r) => {
    const heard = String(r?.album || '').trim();
    const status = String(r?.status || 'attempt');
    const source = String(r?.source || 'unknown');
    const resolvedTo = String(r?.resolvedTo || '').trim();
    const when = String(r?.at || r?.updatedAt || r?.createdAt || '');
    const whenShort = when ? new Date(when).toLocaleString() : '';
    const resolvedFrag = (resolvedTo && resolvedTo.toLowerCase() !== heard.toLowerCase()) ? ` → <strong>${escapeHtml(resolvedTo)}</strong>` : '';
    return `<div style="margin:3px 0;">• <code>${escapeHtml(heard)}</code>${resolvedFrag} <span style="opacity:.8;">[${escapeHtml(status)} · ${escapeHtml(source)}${whenShort ? ' · ' + escapeHtml(whenShort) : ''}]</span></div>`;
  }).join('');
}

function renderPlaylistAliasList(){
  const host = document.getElementById('playlistAliasList');
  if (!host) return;
  const rows = Object.entries(playlistAliasMap || {}).filter(([k,v]) => String(k).trim() && String(v).trim());
  if (!rows.length) {
    host.innerHTML = '<em>No playlist corrections yet.</em>';
  } else {
    host.innerHTML = `<div class="miniTableWrap"><table class="miniTable"><thead><tr><th>What Alexa heard</th><th>Corrected playlist</th><th></th></tr></thead><tbody>${rows
      .sort((a,b)=>a[0].localeCompare(b[0]))
      .map(([heard, corrected]) => `<tr><td><code>${escapeHtml(heard)}</code></td><td><strong>${escapeHtml(corrected)}</strong></td><td><button type="button" class="btn" data-edit-heard-playlist="${encodeURIComponent(heard)}" style="padding:2px 8px;">Edit</button> <button type="button" class="btn" data-heard-playlist="${encodeURIComponent(heard)}" style="padding:2px 8px; margin-left:4px;">Remove</button></td></tr>`)
      .join('')}</tbody></table></div>`;
  }
}

function renderUnresolvedPlaylistList(){
  const host = document.getElementById('unresolvedPlaylistList');
  if (!host) return;
  const rows = Array.isArray(unresolvedPlaylists) ? unresolvedPlaylists : [];
  if (!rows.length) {
    host.innerHTML = '<em>No unresolved playlist names captured yet.</em>';
    return;
  }
  host.innerHTML = `<div class="miniTableWrap"><table class="miniTable"><thead><tr><th>Needs attention</th><th>Seen</th><th>Last seen</th><th></th></tr></thead><tbody>${rows.map((r, idx) => {
    const heard = String(r?.playlist || '').trim();
    const count = Number(r?.count || 1);
    const when = String(r?.updatedAt || r?.createdAt || '');
    const whenShort = when ? new Date(when).toLocaleString() : '';
    return `<tr class="needsAttention"><td><code>${escapeHtml(heard)}</code></td><td>${count}x</td><td>${escapeHtml(whenShort)}</td><td><button type="button" class="btn" data-promote-playlist="${idx}" style="padding:2px 8px;">Promote</button> <button type="button" class="btn" data-dismiss-playlist="${idx}" style="padding:2px 8px; margin-left:4px;">Dismiss</button></td></tr>`;
  }).join('')}</tbody></table></div>`;
}

function renderHeardPlaylistList(){
  const host = document.getElementById('heardPlaylistList');
  if (!host) return;
  const rows = (Array.isArray(heardPlaylists) ? heardPlaylists : []).slice(0, 20);
  if (!rows.length) {
    host.innerHTML = '<em>No recent Alexa playlist inputs yet.</em>';
    return;
  }
  host.innerHTML = rows.map((r) => {
    const heard = String(r?.playlist || '').trim();
    const status = String(r?.status || 'attempt');
    const source = String(r?.source || 'unknown');
    const resolvedTo = String(r?.resolvedTo || '').trim();
    const when = String(r?.at || r?.updatedAt || r?.createdAt || '');
    const whenShort = when ? new Date(when).toLocaleString() : '';
    const resolvedFrag = (resolvedTo && resolvedTo.toLowerCase() !== heard.toLowerCase()) ? ` → <strong>${escapeHtml(resolvedTo)}</strong>` : '';
    return `<div style="margin:3px 0;">• <code>${escapeHtml(heard)}</code>${resolvedFrag} <span style="opacity:.8;">[${escapeHtml(status)} · ${escapeHtml(source)}${whenShort ? ' · ' + escapeHtml(whenShort) : ''}]</span></div>`;
  }).join('');
}

function loadArtistAliasesFromObject(obj){
  artistAliasMap = (obj && typeof obj === 'object' && !Array.isArray(obj)) ? { ...obj } : {};
  renderArtistAliasList();
}

function getArtistAliasesFromUi(){
  const ta = document.getElementById('artistAliasesJson');
  if (ta) {
    try {
      const parsed = JSON.parse(ta.value || '{}');
      if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {
        artistAliasMap = parsed;
      }
    } catch {}
  }
  const out = {};
  for (const [k,v] of Object.entries(artistAliasMap || {})) {
    const kk = normalizeAliasKey(k);
    const vv = String(v || '').trim();
    if (kk && vv) out[kk] = vv;
  }
  artistAliasMap = out;
  renderArtistAliasList();
  return out;
}

const restartModal = document.getElementById('restartModal');
function showRestartModal(){ if (restartModal) restartModal.classList.add('show'); }
function hideRestartModal(){ if (restartModal) restartModal.classList.remove('show'); }

let _savedConfigSnapshot = '';
let _isDirty = false;

function collectConfigSnapshot(){
  const host = document.querySelector('.cfgWrap');
  if (!host) return '';
  const data = {};
  host.querySelectorAll('input, textarea, select').forEach((el) => {
    const id = el.id || el.name;
    if (!id) return;
    if (id === 'out') return;
    if (el.type === 'checkbox' || el.type === 'radio') data[id] = !!el.checked;
    else data[id] = String(el.value ?? '');
  });
  return JSON.stringify(data);
}

function refreshDirtyState(){
  _isDirty = collectConfigSnapshot() !== _savedConfigSnapshot;
}

function markConfigSaved(){
  _savedConfigSnapshot = collectConfigSnapshot();
  _isDirty = false;
}

function confirmIfDirty(){
  refreshDirtyState();
  if (!_isDirty) return true;
  return window.confirm('You have unsaved changes on Config. Leave this page anyway?');
}

function setPillState(pillId, state){
  const pill = document.getElementById(pillId);
  if (!pill) return;
  const dot = pill.querySelector('.dot');
  const map = {
    good: { c: '#22c55e', b: 'rgba(34,197,94,.55)' },
    warn: { c: '#f59e0b', b: 'rgba(245,158,11,.55)' },
    bad:  { c: '#ef4444', b: 'rgba(239,68,68,.55)' },
    off:  { c: '#ef4444', b: 'rgba(239,68,68,.55)' },
    neutral: { c: '#7dd3fc', b: 'rgba(125,211,252,.55)' },
  };
  const s = map[state] || map.neutral;
  if (dot) {
    dot.style.background = s.c;
    dot.style.boxShadow = `0 0 0 6px ${s.b.replace('.55','.20')}`;
  }
  pill.style.borderColor = s.b;
}

function syncAlexaCardVisibility(){
  const featureEl = document.getElementById('featureAlexaSkill');
  const on = !!featureEl?.checked;
  const domainEl = document.getElementById('alexaDomain');
  if (domainEl) domainEl.disabled = !on;
}

function syncLastfmCardVisibility(){
  const featureEl = document.getElementById('featureLastfm');
  const keyEl = document.getElementById('lastfmApiKey');
  const on = !!featureEl?.checked;
  if (keyEl) keyEl.disabled = !on;
  if (on && keyEl && !keyEl.value.trim()) {
    const cached = localStorage.getItem('nowplaying.secret.lastfmApiKey') || '';
    if (cached) keyEl.value = cached;
  }
}

function syncPushoverCardVisibility(){
  const featureEl = document.getElementById('featurePushover');
  const notifyEnabledEl = document.getElementById('notifyEnabled');
  const tokenEl = document.getElementById('pushoverToken');
  const userEl = document.getElementById('pushoverUser');
  const on = !!featureEl?.checked;
  if (notifyEnabledEl) notifyEnabledEl.disabled = !on;
  if (tokenEl) tokenEl.disabled = !on;
  if (userEl) userEl.disabled = !on;
  if (notifyEnabledEl && on && !notifyEnabledEl.checked) notifyEnabledEl.checked = true;
  if (on) {
    if (tokenEl && !tokenEl.value.trim()) tokenEl.value = localStorage.getItem('nowplaying.secret.pushoverToken') || '';
    if (userEl && !userEl.value.trim()) userEl.value = localStorage.getItem('nowplaying.secret.pushoverUser') || '';
  }
}

function syncRatingsCardVisibility(){
  const on = !!document.getElementById('featureRatings')?.checked;
  ['checkRatingsDbBtn','backupRatingsDbBtn','ratingsBackupSelect','restoreRatingsDbBtn'].forEach((id) => {
    const el = document.getElementById(id);
    if (el) el.disabled = !on;
  });
}

let runtimeReady = false;
function applyRuntimeGate(){
  document.querySelectorAll('.gateCard').forEach((el) => {
    el.classList.toggle('blocked', !runtimeReady);
  });
}

const TRACK_KEY_STORAGE = 'nowplaying.trackkey';
const tkEl = document.getElementById('trackKey');
const tkTextEl = document.getElementById('trackKeyText');
const showEl = document.getElementById('showTrackKey');

const savedKey = localStorage.getItem(TRACK_KEY_STORAGE) || '';
if (tkEl) tkEl.value = savedKey;
if (tkTextEl) tkTextEl.value = savedKey;

function persistTrackKey(v){ localStorage.setItem(TRACK_KEY_STORAGE, v || ''); }

if (tkEl) tkEl.addEventListener('input', () => {
  if (tkTextEl) tkTextEl.value = tkEl.value || '';
  persistTrackKey(tkEl.value || '');
});
if (tkTextEl) tkTextEl.addEventListener('input', () => {
  if (tkEl) tkEl.value = tkTextEl.value || '';
  persistTrackKey(tkTextEl.value || '');
});

function getTrackKey(){
  const cfg = document.getElementById('configTrackKey');
  const v = String(cfg?.value || '').trim();
  if (v) return v;
  const cached = String(localStorage.getItem('nowplaying.secret.trackKey') || '').trim();
  if (cached) return cached;
  if (showEl && showEl.checked) return (tkTextEl?.value || '').trim();
  return (tkEl?.value || '').trim();
}

function applyTrackKeyVisibility(){
  if (!tkEl || !tkTextEl || !showEl) return;
  const val = (tkEl.value || tkTextEl.value || '');
  tkEl.value = val;
  tkTextEl.value = val;
  if (showEl.checked) {
    tkEl.style.display = 'none';
    tkTextEl.style.display = '';
  } else {
    tkTextEl.style.display = 'none';
    tkEl.style.display = '';
  }
}

if (showEl) {
  showEl.addEventListener('change', applyTrackKeyVisibility);
  showEl.addEventListener('click', applyTrackKeyVisibility);
}
applyTrackKeyVisibility();

function bindSecretCache(inputId, storageKey){
  const el = document.getElementById(inputId);
  if (!el) return;
  const saved = localStorage.getItem(storageKey) || '';
  if (!String(el.value || '').trim() && saved) el.value = saved;
  el.addEventListener('input', () => {
    const v = String(el.value || '');
    if (v.trim()) localStorage.setItem(storageKey, v);
  });
}

bindSecretCache('configTrackKey', 'nowplaying.secret.trackKey');
bindSecretCache('lastfmApiKey', 'nowplaying.secret.lastfmApiKey');
bindSecretCache('pushoverToken', 'nowplaying.secret.pushoverToken');
bindSecretCache('pushoverUser', 'nowplaying.secret.pushoverUser');

async function loadCfg(){
  const r = await fetch(`${API_BASE}/config/runtime`, { cache:'no-store' });
  const j = await r.json();
  if (!j.ok) return log(j);

  const c = j.config || {};
  const full = j.fullConfig || {};
  const host = location.hostname || '10.0.0.233';
  const apiPortHint = Number(c.ports?.api || 3101);
  const uiPortHint = Number(c.ports?.ui || 8101);
  const apiHint = document.getElementById('apiHint');
  const webHint = document.getElementById('webHint');
  if (apiHint) apiHint.textContent = `${host}:${apiPortHint}`;
  if (webHint) webHint.textContent = `${host}:${uiPortHint}`;
  setPillState('apiPill', 'good');
  setPillState('webPill', 'good');
  const alexaHint = document.getElementById('alexaHint');
  if (alexaHint) {
    const domainTxt = String(c.alexa?.publicDomain || '').trim();
    if (!c.alexa?.enabled) {
      alexaHint.textContent = 'disabled';
      setPillState('alexaPill', 'off');
    } else if (!domainTxt) {
      alexaHint.textContent = 'missing domain';
      setPillState('alexaPill', 'warn');
    } else {
      alexaHint.textContent = domainTxt;
      setPillState('alexaPill', 'good');
    }
  }

  // Preload track key from local cache; fallback to server-provided effective key.
  const localKey = localStorage.getItem(TRACK_KEY_STORAGE) || '';
  const serverKey = String(c.trackKey || '').trim();
  const effectiveKey = localKey || serverKey;
  if (effectiveKey) {
    if (tkEl) tkEl.value = effectiveKey;
    if (tkTextEl) tkTextEl.value = effectiveKey;
    if (!localKey) localStorage.setItem(TRACK_KEY_STORAGE, effectiveKey);
  }

  document.getElementById('featureAlexaSkill').checked = !!c.alexa?.enabled;
  document.getElementById('alexaDomain').value = c.alexa?.publicDomain || '';
  syncAlexaCardVisibility();

  const hasPushover = !!(String(c.notifications?.pushover?.token || '').trim() || String(c.notifications?.pushover?.userKey || '').trim() || c.notifications?.trackNotify?.enabled);
  document.getElementById('featurePushover').checked = hasPushover;
  document.getElementById('notifyEnabled').checked = !!c.notifications?.trackNotify?.enabled;
  document.getElementById('pollMs').value = c.notifications?.trackNotify?.pollMs ?? 3000;
  document.getElementById('dedupeMs').value = c.notifications?.trackNotify?.dedupeMs ?? 15000;
  document.getElementById('alexaMaxAgeMs').value = c.notifications?.trackNotify?.alexaMaxAgeMs ?? 21600000;
  syncPushoverCardVisibility();

  document.getElementById('featurePodcasts').checked = !!c.features?.podcasts;
  document.getElementById('featureRatings').checked = !!c.features?.ratings;
  document.getElementById('featureRadio').checked = !!c.features?.radio;
  syncRatingsCardVisibility();
  const lastfmKey = String(full.lastfmApiKey || localStorage.getItem('nowplaying.secret.lastfmApiKey') || '');
  document.getElementById('featureLastfm').checked = !!lastfmKey;
  document.getElementById('lastfmApiKey').value = lastfmKey;
  if (lastfmKey) localStorage.setItem('nowplaying.secret.lastfmApiKey', lastfmKey);
  syncLastfmCardVisibility();

  document.getElementById('apiPort').value = Number(c.ports?.api || full.ports?.api || 3101);
  document.getElementById('uiPort').value = Number(c.ports?.ui || full.ports?.ui || 8101);
  loadedNodes = Array.isArray(full.nodes) ? full.nodes.slice() : [];
  const node0 = loadedNodes.length ? loadedNodes[0] : {};
  const configuredApiIp = String(node0.ip || '').trim();
  const apiNodeAuto = (!configuredApiIp || configuredApiIp === '10.0.0.233');
  const apiNodePrefill = apiNodeAuto ? host : configuredApiIp;
  document.getElementById('apiNodeIp').value = apiNodePrefill;
  const apiNodeIpHint = document.getElementById('apiNodeIpHint');
  if (apiNodeIpHint) apiNodeIpHint.textContent = apiNodeAuto ? `Auto-defaulted from page host: ${apiNodePrefill}` : `Loaded from config: ${apiNodePrefill}`;

  const configuredMpdHost = String(full.mpd?.host || c.mpd?.host || '').trim();
  const configuredSshHost = String(full.moode?.sshHost || c.moode?.sshHost || '').trim();
  const mpdHostAuto = (!configuredMpdHost || configuredMpdHost === '10.0.0.254');
  const mpdHostPrefill = mpdHostAuto ? 'moode.local' : configuredMpdHost;
  const sshHostPrefill = configuredSshHost || mpdHostPrefill;
  document.getElementById('mpdHost').value = mpdHostPrefill;
  const mpdPortValue = Number(full.mpd?.port || c.mpd?.port || 6600);
  document.getElementById('mpdPort').value = mpdPortValue;
  document.getElementById('moodeSshHost').value = sshHostPrefill;
  const mpdHostHint = document.getElementById('mpdHostHint');
  if (mpdHostHint) mpdHostHint.textContent = mpdHostAuto ? 'Auto-defaulted: moode.local (edit if needed)' : `Loaded from config: ${mpdHostPrefill}`;
  const mpdPortHint = document.getElementById('mpdPortHint');
  if (mpdPortHint) mpdPortHint.textContent = `Default is 6600${mpdPortValue === 6600 ? ' (current)' : ` (current: ${mpdPortValue})`}`;
  document.getElementById('moodeSshUser').value = String(full.moode?.sshUser || c.moode?.sshUser || 'moode');
  refreshSshSetupHelp();
  document.getElementById('moodeBaseUrl').value = String(full.moode?.baseUrl || c.moode?.baseUrl || '');
  const loadedTrackKey = String(full.trackKey || c.trackKey || localStorage.getItem('nowplaying.secret.trackKey') || '');
  document.getElementById('configTrackKey').value = loadedTrackKey;
  if (loadedTrackKey) localStorage.setItem('nowplaying.secret.trackKey', loadedTrackKey);
  document.getElementById('pathMusicLibraryRoot').value = String(full.paths?.musicLibraryRoot || c.paths?.musicLibraryRoot || '/var/lib/mpd/music');
  document.getElementById('pathMoodeUsbMount').value = String(full.paths?.moodeUsbMount || c.paths?.moodeUsbMount || '/media/SamsungMoode');
  document.getElementById('pathPiMountBase').value = String(full.paths?.piMountBase || c.paths?.piMountBase || '/mnt/SamsungMoode');
  document.getElementById('pathPodcastRoot').value = String(full.paths?.podcastRoot || c.paths?.podcastRoot || '/mnt/SamsungMoode/Podcasts');

  loadArtistAliasesFromObject(c.alexa?.artistAliases || {});
  albumAliasMap = (c.alexa?.albumAliases && typeof c.alexa.albumAliases === 'object' && !Array.isArray(c.alexa.albumAliases)) ? { ...c.alexa.albumAliases } : {};
  renderAlbumAliasList();
  playlistAliasMap = (c.alexa?.playlistAliases && typeof c.alexa.playlistAliases === 'object' && !Array.isArray(c.alexa.playlistAliases)) ? { ...c.alexa.playlistAliases } : {};
  renderPlaylistAliasList();
  unresolvedArtists = Array.isArray(c.alexa?.unresolvedArtists) ? c.alexa.unresolvedArtists : [];
  renderUnresolvedArtistList();
  heardArtists = Array.isArray(c.alexa?.heardArtists) ? c.alexa.heardArtists : [];
  renderHeardArtistList();
  unresolvedAlbums = Array.isArray(c.alexa?.unresolvedAlbums) ? c.alexa.unresolvedAlbums : [];
  renderUnresolvedAlbumList();
  heardAlbums = Array.isArray(c.alexa?.heardAlbums) ? c.alexa.heardAlbums : [];
  renderHeardAlbumList();
  unresolvedPlaylists = Array.isArray(c.alexa?.unresolvedPlaylists) ? c.alexa.unresolvedPlaylists : [];
  renderUnresolvedPlaylistList();
  heardPlaylists = Array.isArray(c.alexa?.heardPlaylists) ? c.alexa.heardPlaylists : [];
  renderHeardPlaylistList();

  const pushToken = String(c.notifications?.pushover?.token || localStorage.getItem('nowplaying.secret.pushoverToken') || '');
  const pushUser = String(c.notifications?.pushover?.userKey || localStorage.getItem('nowplaying.secret.pushoverUser') || '');
  document.getElementById('pushoverToken').value = pushToken;
  document.getElementById('pushoverUser').value = pushUser;
  if (pushToken) localStorage.setItem('nowplaying.secret.pushoverToken', pushToken);
  if (pushUser) localStorage.setItem('nowplaying.secret.pushoverUser', pushUser);
  document.getElementById('fullJson').value = JSON.stringify(full, null, 2);

  log({ ok:true, configPath:j.configPath, loadedAt:new Date().toISOString() });
  await loadRatingsBackups();
  await resolveMpdHostIfLocal().catch(() => {});
  await checkRuntimeEnv(true).catch(() => {});
  markConfigSaved();
}

async function saveArtistCorrectionsOnly(showModal = false){
  const key = getTrackKey();
  if (!key) return log('Track key is required to save.');

  let artistAliases = {};
  try {
    artistAliases = getArtistAliasesFromUi();
  } catch (e) {
    return log('Invalid artist corrections: ' + String(e.message || e));
  }

  const payload = {
    config: {
      alexa: {
        artistAliases,
        albumAliases: albumAliasMap,
        playlistAliases: playlistAliasMap,
        unresolvedArtists,
        heardArtists,
        unresolvedAlbums,
        heardAlbums,
        unresolvedPlaylists,
        heardPlaylists,
      },
    },
  };

  const r = await fetch(`${API_BASE}/config/runtime`, {
    method:'POST',
    headers:{ 'Content-Type':'application/json', 'x-track-key': key },
    body: JSON.stringify(payload),
  });
  const j = await r.json();
  log(j);
  if (j && j.ok) markConfigSaved();
  if (showModal && j && j.ok) showRestartModal();
  return j;
}

async function saveCfg(){
  const key = getTrackKey();
  if (!key) return log('Track key is required to save.');

  let artistAliases = {};
  try {
    artistAliases = getArtistAliasesFromUi();
  } catch (e) {
    return log('Invalid artist corrections: ' + String(e.message || e));
  }

  const nodeIp = document.getElementById('apiNodeIp').value.trim();
  const nodesNext = (Array.isArray(loadedNodes) && loadedNodes.length)
    ? loadedNodes.map((n, i) => (i === 0 ? { ...n, ip: nodeIp || n.ip || '' } : n))
    : [{ name: 'pi-main', ip: nodeIp, role: 'both', sshUser: 'brianwis' }];

  const payload = {
    config: {
      alexa: {
        enabled: document.getElementById('featureAlexaSkill').checked,
        publicDomain: document.getElementById('alexaDomain').value.trim(),
        artistAliases,
        albumAliases: albumAliasMap,
        playlistAliases: playlistAliasMap,
        unresolvedArtists,
        heardArtists,
        unresolvedAlbums,
        heardAlbums,
        unresolvedPlaylists,
        heardPlaylists,
      },
      notifications: {
        trackNotify: {
          enabled: document.getElementById('featurePushover').checked ? document.getElementById('notifyEnabled').checked : false,
          pollMs: Number(document.getElementById('pollMs').value || 3000),
          dedupeMs: Number(document.getElementById('dedupeMs').value || 15000),
          alexaMaxAgeMs: Number(document.getElementById('alexaMaxAgeMs').value || 21600000),
        },
        pushover: {
          token: document.getElementById('featurePushover').checked ? document.getElementById('pushoverToken').value.trim() : '',
          userKey: document.getElementById('featurePushover').checked ? document.getElementById('pushoverUser').value.trim() : '',
        },
      },
      features: {
        podcasts: document.getElementById('featurePodcasts').checked,
        ratings: document.getElementById('featureRatings').checked,
        radio: document.getElementById('featureRadio').checked,
      },
      trackKey: document.getElementById('configTrackKey').value.trim(),
      ports: {
        api: Number(document.getElementById('apiPort').value || 3101),
        ui: Number(document.getElementById('uiPort').value || 8101),
      },
      mpd: {
        host: document.getElementById('mpdHost').value.trim(),
        port: Number(document.getElementById('mpdPort').value || 6600),
      },
      moode: {
        sshHost: document.getElementById('moodeSshHost').value.trim(),
        sshUser: document.getElementById('moodeSshUser').value.trim(),
        baseUrl: document.getElementById('moodeBaseUrl').value.trim(),
      },
      paths: {
        musicLibraryRoot: document.getElementById('pathMusicLibraryRoot').value.trim(),
        moodeUsbMount: document.getElementById('pathMoodeUsbMount').value.trim(),
        piMountBase: document.getElementById('pathPiMountBase').value.trim(),
        podcastRoot: document.getElementById('pathPodcastRoot').value.trim(),
      },
      runtime: {
      },
      nodes: nodesNext,
      lastfmApiKey: document.getElementById('featureLastfm').checked ? document.getElementById('lastfmApiKey').value.trim() : '',
    },
  };

  const r = await fetch(`${API_BASE}/config/runtime`, {
    method:'POST',
    headers:{ 'Content-Type':'application/json', 'x-track-key': key },
    body: JSON.stringify(payload),
  });

  const j = await r.json();
  log(j);
  if (j && j.ok) {
    markConfigSaved();
    showRestartModal();
  }
}

async function saveFullCfg(){
  const key = getTrackKey();
  if (!key) return log('Track key is required to save.');
  let full;
  try {
    full = JSON.parse(document.getElementById('fullJson').value || '{}');
  } catch (e) {
    return log('Invalid JSON: ' + String(e.message || e));
  }

  const r = await fetch(`${API_BASE}/config/runtime`, {
    method:'POST',
    headers:{ 'Content-Type':'application/json', 'x-track-key': key },
    body: JSON.stringify({ fullConfig: full }),
  });
  const j = await r.json();
  log(j);
  if (j && j.ok) {
    markConfigSaved();
    showRestartModal();
  }
}

function formatFullJson(){
  try {
    const v = JSON.parse(document.getElementById('fullJson').value || '{}');
    document.getElementById('fullJson').value = JSON.stringify(v, null, 2);
  } catch (e) {
    log('Invalid JSON: ' + String(e.message || e));
  }
}

async function restartServicesNow(){
  const key = getTrackKey();
  if (!key) return log('Track key is required to restart services.');

  // Hide first because restarting can interrupt response.
  hideRestartModal();

  try {
    const r = await fetch(`${API_BASE}/config/restart-services`, {
      method:'POST',
      headers:{ 'Content-Type':'application/json', 'x-track-key': key },
      body: JSON.stringify({}),
    });

    const txt = await r.text();
    let j = null;
    try { j = txt ? JSON.parse(txt) : null; } catch {}

    if (j) log(j);
    else log(`Service restart requested${r.ok ? '.' : ` (HTTP ${r.status})`}`);
  } catch (e) {
    log('Restart requested. The API connection dropped while services were restarting (this is expected). Visit other pages to explore features.');
    setTimeout(() => {
      loadCfg().catch(() => {});
    }, 5000);
  }
}

async function checkRatingsDb(){
  const key = getTrackKey();
  const statusEl = document.getElementById('ratingsDbStatus');
  const btn = document.getElementById('checkRatingsDbBtn');
  if (!key) return log('Track key is required to check ratings DB.');

  if (btn) btn.disabled = true;
  if (statusEl) statusEl.textContent = 'Checking ratings sticker DB…';
  try {
    const r = await fetch(`${API_BASE}/config/ratings/sticker-status`, {
      method:'GET',
      headers:{ 'x-track-key': key },
      cache:'no-store',
    });
    const j = await r.json().catch(() => ({}));
    if (!r.ok || !j?.ok) throw new Error(j?.error || `HTTP ${r.status}`);
    if (statusEl) statusEl.textContent = j.exists
      ? `✅ Found sticker DB at ${j.path} (${j.size || 0} bytes).`
      : `⚠️ Sticker DB not found at ${j.path}. It may be created after first rating write.`;
  } catch (e) {
    if (statusEl) statusEl.textContent = `❌ Ratings DB check failed: ${String(e?.message || e)}`;
  } finally {
    if (btn) btn.disabled = false;
  }
}

async function loadRatingsBackups(){
  const key = getTrackKey();
  const sel = document.getElementById('ratingsBackupSelect');
  if (!sel || !key) return;
  try {
    const r = await fetch(`${API_BASE}/config/ratings/sticker-backups`, {
      method:'GET',
      headers:{ 'x-track-key': key },
      cache:'no-store',
    });
    const j = await r.json().catch(() => ({}));
    if (!r.ok || !j?.ok) throw new Error(j?.error || `HTTP ${r.status}`);
    const list = Array.isArray(j.backups) ? j.backups : [];
    sel.innerHTML = list.length
      ? list.map((b) => `<option value="${b.path}">${b.name} (${Number(b.size||0).toLocaleString()} bytes)</option>`).join('')
      : '<option value="">(no backups found)</option>';
  } catch {
    sel.innerHTML = '<option value="">(unable to load backups)</option>';
  }
}

async function backupRatingsDb(){
  const key = getTrackKey();
  const statusEl = document.getElementById('ratingsDbStatus');
  const btn = document.getElementById('backupRatingsDbBtn');
  if (!key) return log('Track key is required to back up ratings DB.');

  if (btn) btn.disabled = true;
  if (statusEl) statusEl.textContent = 'Creating ratings DB backup…';
  try {
    const r = await fetch(`${API_BASE}/config/ratings/sticker-backup`, {
      method:'POST',
      headers:{ 'Content-Type':'application/json', 'x-track-key': key },
      body: JSON.stringify({}),
    });
    const j = await r.json().catch(() => ({}));
    if (!r.ok || !j?.ok) throw new Error(j?.error || `HTTP ${r.status}`);
    if (statusEl) statusEl.textContent = `✅ Backup created: ${j.backupPath}`;
    await loadRatingsBackups();
  } catch (e) {
    if (statusEl) statusEl.textContent = `❌ Ratings DB backup failed: ${String(e?.message || e)}`;
  } finally {
    if (btn) btn.disabled = false;
  }
}

async function restoreRatingsDb(){
  const key = getTrackKey();
  const statusEl = document.getElementById('ratingsDbStatus');
  const btn = document.getElementById('restoreRatingsDbBtn');
  const sel = document.getElementById('ratingsBackupSelect');
  const backupPath = String(sel?.value || '').trim();

  if (!key) return log('Track key is required to restore ratings DB.');
  if (!backupPath) {
    if (statusEl) statusEl.textContent = 'Select a backup first.';
    return;
  }
  if (!window.confirm(`Restore ratings DB from:\n${backupPath}\n\nThis will overwrite current sticker DB.`)) return;

  if (btn) btn.disabled = true;
  if (statusEl) statusEl.textContent = 'Restoring ratings DB…';
  try {
    const r = await fetch(`${API_BASE}/config/ratings/sticker-restore`, {
      method:'POST',
      headers:{ 'Content-Type':'application/json', 'x-track-key': key },
      body: JSON.stringify({ backupPath }),
    });
    const j = await r.json().catch(() => ({}));
    if (!r.ok || !j?.ok) throw new Error(j?.error || `HTTP ${r.status}`);
    if (statusEl) statusEl.textContent = `✅ Restored ratings DB from ${j.backupPath}`;
  } catch (e) {
    if (statusEl) statusEl.textContent = `❌ Ratings DB restore failed: ${String(e?.message || e)}`;
  } finally {
    if (btn) btn.disabled = false;
  }
}

async function checkRuntimeEnv(silent = false){
  const key = getTrackKey();
  const statusEl = document.getElementById('runtimeCheckStatus');
  const detailsEl = document.getElementById('runtimeCheckDetails');
  const btn = document.getElementById('checkRuntimeBtn');
  if (!key) return log('Track key is required to check runtime env.');

  const mpdHost = String(document.getElementById('mpdHost')?.value || '').trim();
  const mpdPort = Number(document.getElementById('mpdPort')?.value || 6600);
  const sshHostRaw = String(document.getElementById('moodeSshHost')?.value || '').trim();
  const sshHost = sshHostRaw || mpdHost;
  const sshUser = String(document.getElementById('moodeSshUser')?.value || 'moode').trim();
  const paths = {
    musicLibraryRoot: String(document.getElementById('pathMusicLibraryRoot')?.value || '').trim(),
    moodeUsbMount: String(document.getElementById('pathMoodeUsbMount')?.value || '').trim(),
    piMountBase: String(document.getElementById('pathPiMountBase')?.value || '').trim(),
    podcastRoot: String(document.getElementById('pathPodcastRoot')?.value || '').trim(),
  };

  if (btn) btn.disabled = true;
  if (!silent && statusEl) statusEl.textContent = 'Checking SSH/MPD/paths…';
  if (!silent && detailsEl) detailsEl.innerHTML = '';
  try {
    const r = await fetch(`${API_BASE}/config/runtime/check-env`, {
      method:'POST',
      headers:{ 'Content-Type':'application/json', 'x-track-key': key },
      body: JSON.stringify({ mpdHost, mpdPort, sshHost, sshUser, paths }),
    });
    const j = await r.json().catch(() => ({}));
    if (!r.ok || !j?.ok) throw new Error(j?.error || `HTTP ${r.status}`);

    const ssh = j.sshOk ? 'SSH ✅' : 'SSH ❌';
    const mpd = j.mpdOk ? 'MPD ✅' : 'MPD ❌';
    const bad = (j.pathChecks || []).filter((x) => !x.exists).length;
    runtimeReady = !!(j.sshOk && j.mpdOk);
    applyRuntimeGate();
    if (!silent && statusEl) statusEl.textContent = `${ssh} · ${mpd} · Paths ${bad ? `⚠️ ${bad} missing` : '✅'}`;

    if (!silent && detailsEl) {
      const rows = Array.isArray(j.pathChecks) ? j.pathChecks : [];
      const podcastsEnabled = !!document.getElementById('featurePodcasts')?.checked;
      const podcastRow = rows.find((x) => x && x.name === 'podcastRoot');
      const needsPodcastCreate = podcastsEnabled && podcastRow && !podcastRow.exists;
      const table = rows.length ? `
        <table class="miniTable" style="margin-top:6px;">
          <thead><tr><th>Path</th><th>Status</th></tr></thead>
          <tbody>
            ${rows.map((x) => `<tr style="background:${x.exists ? 'rgba(34,197,94,.10)' : 'rgba(239,68,68,.12)'}"><td><code>${escapeHtml(x.path || '')}</code></td><td>${x.exists ? '✅ Found' : '❌ Missing'}</td></tr>`).join('')}
          </tbody>
        </table>
      ` : '<em>No path checks returned.</em>';
      const podcastHint = needsPodcastCreate
        ? `<div style="margin-top:8px; display:flex; gap:8px; align-items:center;"><span>Podcasts is enabled and podcast root is missing.</span><button class="btn" id="createPodcastRootBtn" type="button">Create Podcasts Folder</button></div>`
        : '';
      detailsEl.innerHTML = table + podcastHint;
      const createBtn = document.getElementById('createPodcastRootBtn');
      if (createBtn) createBtn.addEventListener('click', () => ensurePodcastRoot().catch(e => log(String(e))));
    }
  } catch (e) {
    runtimeReady = false;
    applyRuntimeGate();
    if (!silent && statusEl) statusEl.textContent = `❌ Runtime check failed: ${String(e?.message || e)}`;
  } finally {
    if (btn) btn.disabled = false;
  }
}

async function ensurePodcastRoot(){
  const key = getTrackKey();
  const statusEl = document.getElementById('runtimeCheckStatus');
  const detailsEl = document.getElementById('runtimeCheckDetails');
  if (!key) return log('Track key is required.');

  const mpdHost = String(document.getElementById('mpdHost')?.value || '').trim();
  const sshHostRaw = String(document.getElementById('moodeSshHost')?.value || '').trim();
  const sshHost = sshHostRaw || mpdHost;
  const sshUser = String(document.getElementById('moodeSshUser')?.value || 'moode').trim();
  const podcastRoot = String(document.getElementById('pathPodcastRoot')?.value || '').trim();
  if (!podcastRoot) return;

  if (!window.confirm(`Create missing podcast folder?\n\n${podcastRoot}`)) return;
  if (statusEl) statusEl.textContent = 'Creating podcast folder…';

  try {
    const r = await fetch(`${API_BASE}/config/runtime/ensure-podcast-root`, {
      method:'POST',
      headers:{ 'Content-Type':'application/json', 'x-track-key': key },
      body: JSON.stringify({ sshHost, sshUser, podcastRoot }),
    });
    const j = await r.json().catch(() => ({}));
    if (!r.ok || !j?.ok) throw new Error(j?.error || `HTTP ${r.status}`);
    if (statusEl) statusEl.textContent = `✅ Created ${j.podcastRoot}`;
    await checkRuntimeEnv();
  } catch (e) {
    if (statusEl) statusEl.textContent = `❌ Create folder failed: ${String(e?.message || e)}`;
    if (detailsEl) detailsEl.innerHTML = '';
  }
}

function refreshSshSetupHelp(){
  const el = document.getElementById('sshSetupCmds');
  if (!el) return;
  const mpdHost = String(document.getElementById('mpdHost')?.value || '').trim();
  const sshHostRaw = String(document.getElementById('moodeSshHost')?.value || '').trim();
  const sshHost = sshHostRaw || mpdHost || '<moode-host>';
  const sshUser = String(document.getElementById('moodeSshUser')?.value || '').trim() || 'moode';
  el.textContent = `ssh-keygen -t ed25519 -C "now-playing-api"
ssh-copy-id ${sshUser}@${sshHost}
ssh ${sshUser}@${sshHost} 'echo ok'
ssh ${sshUser}@${sshHost} 'sudo -n true && echo sudo_ok'`;
}

function derivePathsFromMoode(){
  const moode = String(document.getElementById('pathMoodeUsbMount')?.value || '').trim();
  const statusEl = document.getElementById('runtimeCheckStatus');
  if (!moode) {
    if (statusEl) statusEl.textContent = 'Enter path (1) first (ex. /media/NAMEOFYOURDRIVE).';
    return;
  }

  // Accept both /media/<drive> and /media/<drive>/Podcasts
  const parts = moode.split('/').filter(Boolean);
  const mediaIdx = parts.indexOf('media');
  let drive = '';
  if (mediaIdx >= 0 && parts.length > mediaIdx + 1) drive = parts[mediaIdx + 1];
  if (!drive && parts.length >= 2) drive = parts[parts.length - 1];
  if (!drive || /^podcasts$/i.test(drive)) {
    if (statusEl) statusEl.textContent = 'Could not detect drive name from path (1). Use /media/DRIVENAME.';
    return;
  }

  const piEl = document.getElementById('pathPiMountBase');
  const podEl = document.getElementById('pathPodcastRoot');
  if (piEl) piEl.value = `/mnt/${drive}`;
  if (podEl) podEl.value = `/mnt/${drive}/Podcasts`;
  if (statusEl) statusEl.textContent = `Auto-filled paths using drive: ${drive}`;
  refreshDirtyState();
}

async function checkAlexaDomain(){
  const key = getTrackKey();
  const statusEl = document.getElementById('alexaDomainCheckStatus');
  const btn = document.getElementById('checkAlexaDomainBtn');
  const domain = String(document.getElementById('alexaDomain')?.value || '').trim();

  if (!key) return log('Track key is required to check domain.');
  if (!domain) {
    if (statusEl) statusEl.textContent = 'Enter a public domain first.';
    return;
  }

  if (btn) btn.disabled = true;
  if (statusEl) statusEl.textContent = 'Checking domain…';

  try {
    const r = await fetch(`${API_BASE}/config/alexa/check-domain`, {
      method:'POST',
      headers:{ 'Content-Type':'application/json', 'x-track-key': key },
      body: JSON.stringify({ domain }),
    });
    const j = await r.json().catch(() => ({}));
    if (!r.ok || !j?.ok) throw new Error(j?.error || `HTTP ${r.status}`);

    const ok = !!j.reachable;
    if (statusEl) statusEl.textContent = ok
      ? `✅ Reachable: ${j.url} (HTTP ${j.statusCode || 'ok'})`
      : `⚠️ Not reachable: ${j.url}${j.statusCode ? ` (HTTP ${j.statusCode})` : ''}`;
    const ah = document.getElementById('alexaHint');
    if (ah) ah.textContent = domain;
    setPillState('alexaPill', ok ? 'good' : 'warn');
  } catch (e) {
    if (statusEl) statusEl.textContent = `❌ Check failed: ${String(e?.message || e)}`;
    const ah = document.getElementById('alexaHint');
    if (ah) ah.textContent = domain;
    setPillState('alexaPill', 'bad');
  } finally {
    if (btn) btn.disabled = false;
  }
}

document.getElementById('artistAliasList').addEventListener('click', async (e) => {
  const editBtn = e.target.closest('button[data-edit-heard]');
  if (editBtn) {
    const k = decodeURIComponent(String(editBtn.getAttribute('data-edit-heard') || ''));
    if (!k) return;
    const current = String(artistAliasMap[k] || '').trim();
    const next = window.prompt(`Edit corrected artist for "${k}"`, current);
    if (next == null) return;
    const v = String(next).trim();
    if (!v) {
      delete artistAliasMap[k];
    } else {
      artistAliasMap[k] = v;
    }
    renderArtistAliasList();
    try { await saveArtistCorrectionsOnly(false); } catch (err) { log(String(err)); }
    return;
  }

  const btn = e.target.closest('button[data-heard]');
  if (!btn) return;
  const k = decodeURIComponent(String(btn.getAttribute('data-heard') || ''));
  if (!k) return;
  delete artistAliasMap[k];
  renderArtistAliasList();
  try { await saveArtistCorrectionsOnly(false); } catch (err) { log(String(err)); }
});

document.getElementById('unresolvedArtistList').addEventListener('click', async (e) => {
  const promoteBtn = e.target.closest('button[data-promote]');
  const dismissBtn = e.target.closest('button[data-dismiss]');

  if (promoteBtn) {
    const idx = Number(promoteBtn.getAttribute('data-promote'));
    const row = unresolvedArtists[idx] || {};
    const heardRaw = String(row.artist || '').trim();
    if (!heardRaw) return;
    const suggested = String(artistAliasMap[normalizeAliasKey(heardRaw)] || heardRaw).trim();
    const corrected = window.prompt(`Corrected library name for "${heardRaw}"`, suggested);
    if (!corrected || !String(corrected).trim()) return;
    artistAliasMap[normalizeAliasKey(heardRaw)] = String(corrected).trim();
    unresolvedArtists.splice(idx, 1);
    renderArtistAliasList();
    renderUnresolvedArtistList();
    try { await saveArtistCorrectionsOnly(false); } catch (err) { log(String(err)); }
    return;
  }

  if (dismissBtn) {
    const idx = Number(dismissBtn.getAttribute('data-dismiss'));
    if (!Number.isFinite(idx)) return;
    unresolvedArtists.splice(idx, 1);
    renderUnresolvedArtistList();
    try { await saveArtistCorrectionsOnly(false); } catch (err) { log(String(err)); }
  }
});

document.getElementById('albumAliasList').addEventListener('click', async (e) => {
  const editBtn = e.target.closest('button[data-edit-heard-album]');
  if (editBtn) {
    const k = decodeURIComponent(String(editBtn.getAttribute('data-edit-heard-album') || ''));
    if (!k) return;
    const current = String(albumAliasMap[k] || '').trim();
    const next = window.prompt(`Edit corrected album for "${k}"`, current);
    if (next == null) return;
    const v = String(next).trim();
    if (!v) {
      delete albumAliasMap[k];
    } else {
      albumAliasMap[k] = v;
    }
    renderAlbumAliasList();
    try { await saveArtistCorrectionsOnly(false); } catch (err) { log(String(err)); }
    return;
  }

  const btn = e.target.closest('button[data-heard-album]');
  if (!btn) return;
  const k = decodeURIComponent(String(btn.getAttribute('data-heard-album') || ''));
  if (!k) return;
  delete albumAliasMap[k];
  renderAlbumAliasList();
  try { await saveArtistCorrectionsOnly(false); } catch (err) { log(String(err)); }
});

document.getElementById('unresolvedAlbumList').addEventListener('click', async (e) => {
  const promoteBtn = e.target.closest('button[data-promote-album]');
  const dismissBtn = e.target.closest('button[data-dismiss-album]');

  if (promoteBtn) {
    const idx = Number(promoteBtn.getAttribute('data-promote-album'));
    const row = unresolvedAlbums[idx] || {};
    const heardRaw = String(row.album || '').trim();
    if (!heardRaw) return;
    const suggested = String(albumAliasMap[normalizeAliasKey(heardRaw)] || heardRaw).trim();
    const corrected = window.prompt(`Corrected album name for "${heardRaw}"`, suggested);
    if (!corrected || !String(corrected).trim()) return;
    albumAliasMap[normalizeAliasKey(heardRaw)] = String(corrected).trim();
    unresolvedAlbums.splice(idx, 1);
    renderAlbumAliasList();
    renderUnresolvedAlbumList();
    try { await saveArtistCorrectionsOnly(false); } catch (err) { log(String(err)); }
    return;
  }

  if (dismissBtn) {
    const idx = Number(dismissBtn.getAttribute('data-dismiss-album'));
    if (!Number.isFinite(idx)) return;
    unresolvedAlbums.splice(idx, 1);
    renderUnresolvedAlbumList();
    try { await saveArtistCorrectionsOnly(false); } catch (err) { log(String(err)); }
  }
});

document.getElementById('playlistAliasList').addEventListener('click', async (e) => {
  const editBtn = e.target.closest('button[data-edit-heard-playlist]');
  if (editBtn) {
    const k = decodeURIComponent(String(editBtn.getAttribute('data-edit-heard-playlist') || ''));
    if (!k) return;
    const current = String(playlistAliasMap[k] || '').trim();
    const next = window.prompt(`Edit corrected playlist for "${k}"`, current);
    if (next == null) return;
    const v = String(next).trim();
    if (!v) delete playlistAliasMap[k]; else playlistAliasMap[k] = v;
    renderPlaylistAliasList();
    try { await saveArtistCorrectionsOnly(false); } catch (err) { log(String(err)); }
    return;
  }

  const btn = e.target.closest('button[data-heard-playlist]');
  if (!btn) return;
  const k = decodeURIComponent(String(btn.getAttribute('data-heard-playlist') || ''));
  if (!k) return;
  delete playlistAliasMap[k];
  renderPlaylistAliasList();
  try { await saveArtistCorrectionsOnly(false); } catch (err) { log(String(err)); }
});

document.getElementById('unresolvedPlaylistList').addEventListener('click', async (e) => {
  const promoteBtn = e.target.closest('button[data-promote-playlist]');
  const dismissBtn = e.target.closest('button[data-dismiss-playlist]');

  if (promoteBtn) {
    const idx = Number(promoteBtn.getAttribute('data-promote-playlist'));
    const row = unresolvedPlaylists[idx] || {};
    const heardRaw = String(row.playlist || '').trim();
    if (!heardRaw) return;
    const suggested = String(playlistAliasMap[normalizeAliasKey(heardRaw)] || heardRaw).trim();
    const corrected = window.prompt(`Corrected playlist name for "${heardRaw}"`, suggested);
    if (!corrected || !String(corrected).trim()) return;
    playlistAliasMap[normalizeAliasKey(heardRaw)] = String(corrected).trim();
    unresolvedPlaylists.splice(idx, 1);
    renderPlaylistAliasList();
    renderUnresolvedPlaylistList();
    try { await saveArtistCorrectionsOnly(false); } catch (err) { log(String(err)); }
    return;
  }

  if (dismissBtn) {
    const idx = Number(dismissBtn.getAttribute('data-dismiss-playlist'));
    if (!Number.isFinite(idx)) return;
    unresolvedPlaylists.splice(idx, 1);
    renderUnresolvedPlaylistList();
    try { await saveArtistCorrectionsOnly(false); } catch (err) { log(String(err)); }
  }
});

document.getElementById('artistAliasesJson').addEventListener('input', () => {
  try {
    const parsed = JSON.parse(document.getElementById('artistAliasesJson').value || '{}');
    if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {
      artistAliasMap = parsed;
      renderArtistAliasList();
    }
  } catch {}
});

document.getElementById('featureAlexaSkill')?.addEventListener('change', syncAlexaCardVisibility);
document.getElementById('featureLastfm')?.addEventListener('change', syncLastfmCardVisibility);
document.getElementById('featurePushover')?.addEventListener('change', syncPushoverCardVisibility);
document.getElementById('featureRatings')?.addEventListener('change', () => {
  syncRatingsCardVisibility();
  if (document.getElementById('featureRatings')?.checked) loadRatingsBackups().catch(() => {});
});
document.getElementById('checkAlexaDomainBtn')?.addEventListener('click', () => checkAlexaDomain().catch(e => log(String(e))));
document.getElementById('checkRuntimeBtn')?.addEventListener('click', () => checkRuntimeEnv().catch(e => log(String(e))));
document.getElementById('pathMoodeUsbMount')?.addEventListener('input', derivePathsFromMoode);
document.getElementById('pathMoodeUsbMount')?.addEventListener('change', derivePathsFromMoode);
// derivePathsBtn removed; auto-derive runs on input/change.
document.getElementById('moodeSshHost')?.addEventListener('input', refreshSshSetupHelp);
document.getElementById('moodeSshUser')?.addEventListener('input', refreshSshSetupHelp);
document.getElementById('mpdHost')?.addEventListener('input', refreshSshSetupHelp);
document.getElementById('checkRatingsDbBtn')?.addEventListener('click', () => checkRatingsDb().catch(e => log(String(e))));
document.getElementById('backupRatingsDbBtn')?.addEventListener('click', () => backupRatingsDb().catch(e => log(String(e))));
document.getElementById('restoreRatingsDbBtn')?.addEventListener('click', () => restoreRatingsDb().catch(e => log(String(e))));

// Unsaved changes guard (tab clicks + page close)
document.querySelectorAll('.cfgWrap input, .cfgWrap textarea, .cfgWrap select').forEach((el) => {
  el.addEventListener('input', refreshDirtyState);
  el.addEventListener('change', refreshDirtyState);
});

document.querySelectorAll('.topTabs a').forEach((a) => {
  a.addEventListener('click', (e) => {
    const href = a.getAttribute('href') || '';
    if (!href || href.includes('config.html')) return;
    if (!confirmIfDirty()) e.preventDefault();
  });
});

window.addEventListener('beforeunload', (e) => {
  refreshDirtyState();
  if (!_isDirty) return;
  e.preventDefault();
  e.returnValue = '';
});
document.getElementById('reloadBtn').onclick = () => loadCfg().catch(e => log(String(e)));
document.getElementById('saveBtn').onclick = () => saveCfg().catch(e => log(String(e)));
document.getElementById('saveFullBtn').onclick = () => saveFullCfg().catch(e => log(String(e)));
document.getElementById('formatJsonBtn').onclick = () => formatFullJson();
document.getElementById('modalLaterBtn').onclick = () => hideRestartModal();
document.getElementById('modalRestartBtn').onclick = () => restartServicesNow().catch(e => log(String(e)));
syncAlexaCardVisibility();
syncLastfmCardVisibility();
syncPushoverCardVisibility();
syncRatingsCardVisibility();
applyRuntimeGate();
refreshSshSetupHelp();
applyInitialNetworkPrefills();
loadCfg().catch(e => log(String(e)));
</script>
</body>
</html>
