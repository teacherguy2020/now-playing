<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Now Playing</title>
  <link rel="stylesheet" href="styles/podcasts.css?v=20260218-82" />
  <link rel="stylesheet" href="styles/podcasts2.css?v=20260209-2" />
  <style>
    body{background:#0c1526;color:#e7eefc;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
    .viewWrap{max-width:1080px;width:min(1080px, calc(100vw - 24px));margin:0 auto;padding:2px 0 14px;box-sizing:border-box}
    #appFrame{width:100% !important;height:1400px;min-height:0;border:1px solid #2a3a58;border-radius:14px;background:#071021;display:block;box-sizing:border-box}
    #themeToggle{min-width:44px;padding:8px 12px;font-size:16px;line-height:1}
    /* In app-shell mode, let top chrome scroll away (not sticky) to maximize iframe area */
    .preHeroStatusWrap,
    .heroRail{position:relative !important; top:auto !important;}
    .heroRail{backdrop-filter:none !important; -webkit-backdrop-filter:none !important;}
    .heroQueueCard{margin-top:10px;border:1px solid #2a3a58;border-radius:14px;padding:10px;background:rgba(10,18,34,.45)}
    .heroQueueHead{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
    .heroQueueTitle{display:none}
    .heroQueueWrap{overflow:visible;border:1px solid #2a3a58;border-radius:10px;padding:8px;background:#071021}
    .heroQueueRow{display:flex;gap:8px;align-items:center;padding:6px;border-bottom:1px dashed #233650}
    .heroQueueRow:last-child{border-bottom:none}
    .heroQueueMeta{color:#9fb1d9;font-size:12px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    #heroQueueNextUp .heroQueueMeta{font-size:18px;font-weight:600;line-height:1.2}
    .heroQueueActions{display:flex;gap:4px;margin-left:auto}
    .heroQueueNextUp{display:none;margin-bottom:8px;border:1px solid #2a3a58;border-radius:10px;padding:8px;background:#071021;align-items:center;gap:8px}
    .heroQueueNextUp img{width:34px;height:34px;border-radius:7px;object-fit:cover;border:1px solid #334;background:#0a1222}
    .heroQueueBtn,
    .heroQueueActions button{padding:4px 8px;border-radius:7px;border:1px solid #334;background:#0a1222;color:#eef;cursor:pointer;transition:all .12s ease}
    .heroQueueBtn{padding:6px 10px;border-radius:8px}
    .heroQueueBtn:hover,
    .heroQueueActions button:hover{background:#12203c;border-color:#4b5f86;box-shadow:0 0 0 1px rgba(125,211,252,.25) inset}
    .heroQueueBtn:active,
    .heroQueueActions button:active{transform:scale(.97);background:#16294b;border-color:#7dd3fc;box-shadow:0 0 0 2px rgba(125,211,252,.35) inset}

    body.theme-light #appFrame{background:rgba(233,226,246,.78);border-color:rgba(63,47,95,.28)}
    body.theme-light .heroQueueCard{background:rgba(255,242,224,.52);border-color:rgba(137,138,196,.42)}
    body.theme-light .heroQueueWrap,
    body.theme-light .heroQueueNextUp{background:rgba(255,255,255,.70);border-color:rgba(137,138,196,.42)}
    body.theme-light .heroQueueTitle,
    body.theme-light .heroQueueMeta{color:#3b3260}
    body.theme-light .heroQueueRow{border-bottom-color:rgba(137,138,196,.35)}
    body.theme-light .heroQueueRow[style*='34,197,94']{background:rgba(22,163,74,.14)!important}
    body.theme-light .heroQueueBtn,
    body.theme-light .heroQueueActions button{background:#c0c9ee;color:#2f2a4f;border-color:rgba(137,138,196,.42)}
    body.theme-light .heroQueueBtn:hover,
    body.theme-light .heroQueueActions button:hover{background:#d7def4;border-color:rgba(137,138,196,.56);box-shadow:0 0 0 1px rgba(137,138,196,.26) inset}
    body.theme-light .heroQueueBtn:active,
    body.theme-light .heroQueueActions button:active{background:#c8d2f0;border-color:rgba(137,138,196,.62)}
    body.theme-light .queueAlbumCard{background:rgba(233,226,246,.96);border-color:rgba(63,47,95,.30)}
    body.theme-light .queueAlbumClose,
    body.theme-light .queueAlbumTrackBtn,
    body.theme-light .queueArtistAlbumBtn{background:rgba(255,255,255,.72);color:#2f2a4f;border-color:rgba(137,138,196,.42)}
    body.theme-light .queueAlbumTitle{color:#1f1833}
    body.theme-light .queueAlbumSub,
    body.theme-light .queueAlbumLineBtn{color:#4b3e6f}
    body.theme-light .queueAlbumTrackTitle{color:#1f1833}
    body.theme-light .queueAlbumTrackNum{color:#6b5f90}
    body.theme-light .queueAlbumTrackRow{border-bottom-color:rgba(137,138,196,.42)}
    body.theme-light .queueAlbumTracks{border-top-color:rgba(137,138,196,.46)}

    .queueAlbumModal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(2,8,20,.72);z-index:9999;padding:16px}
    .queueAlbumModal.open{display:flex}
    .queueAlbumCard{max-width:min(760px,96vw);width:100%;background:#0f1a31;border:1px solid #2a3a58;border-radius:14px;padding:14px;box-shadow:0 20px 60px rgba(0,0,0,.45)}
    .queueAlbumHead{display:flex;justify-content:space-between;align-items:center;gap:10px}
    .queueAlbumClose{padding:6px 10px;border-radius:8px;border:1px solid #334;background:#0a1222;color:#eef;cursor:pointer}
    .queueAlbumBody{display:grid;grid-template-columns:120px 1fr;gap:12px;margin-top:10px}
    .queueAlbumBody img{width:120px;height:120px;border-radius:10px;object-fit:cover;border:1px solid #334;background:#0a1222}
    .queueAlbumMeta{display:grid;gap:6px}
    .queueAlbumTitle{font-size:22px;color:#eaf3ff;font-weight:700;line-height:1.2}
    .queueAlbumSub{font-size:14px;color:#9fb1d9}
    .queueAlbumLineBtn{border:0;background:transparent;color:#9fb1d9;padding:0;cursor:pointer;font:inherit;text-align:left;text-decoration:underline;text-underline-offset:2px}
    .queueAlbumTracks{grid-column:1 / -1;margin-top:8px;max-height:48vh;overflow:auto;border-top:1px solid #2a3a58;padding-top:8px}
    .queueAlbumTrackRow{display:grid;grid-template-columns:34px minmax(0,1fr) auto;align-items:center;gap:10px;padding:6px 4px;border-bottom:1px dashed #23324f}
    .queueAlbumTrackNum{color:#9fb1d9;font-weight:600;text-align:right}
    .queueAlbumTrackTitle{min-width:0;color:#eaf3ff;line-height:1.25;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .queueAlbumTrackActions{display:flex;gap:6px;flex-wrap:nowrap;justify-content:flex-end}
    .queueAlbumTrackBtn{padding:4px 8px !important;min-width:auto !important;font-size:13px;line-height:1.1;white-space:nowrap}
    .queueArtistGrid{grid-column:1 / -1;display:grid;grid-template-columns:repeat(auto-fill,minmax(140px,1fr));gap:10px;margin-top:10px;max-height:48vh;overflow:auto}
    .queueArtistAlbumBtn{border:1px solid #2a3a58;background:#0a1222;border-radius:10px;padding:8px;color:#eaf3ff;cursor:pointer;text-align:left}
    .queueArtistAlbumBtn img{width:100%;aspect-ratio:1/1;object-fit:cover;border-radius:8px;border:1px solid #334;background:#071021;margin-bottom:6px}
    .queueArtistAlbumName{font-size:13px;line-height:1.2;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden}
  </style>
</head>
<body>
  <div class="preHeroStatusWrap">
    <div class="preHeroStatus">
      <div class="pill" id="apiPill" title="Active API endpoint"><span class="dot" aria-hidden="true"></span>API: <span id="apiHint">loadingâ€¦</span></div>
      <div class="pill" id="webPill" title="Active web UI endpoint"><span class="dot" aria-hidden="true"></span>Web: <span id="webHint">loadingâ€¦</span></div>
      <div class="pill" id="alexaPill" title="Alexa public domain health"><span class="dot" aria-hidden="true"></span>Alexa: <span id="alexaHint">unknown</span></div>
      <div class="pill" id="moodePill" title="moOde host verification"><span class="dot" aria-hidden="true"></span>moOde: <span id="moodeHint">unknown</span></div>
    </div>
  </div>

  <div class="heroRail">
    <div class="heroWrap">
      <div style="display:flex;gap:10px;justify-content:flex-start;align-items:flex-end;flex-wrap:wrap;">
        <nav class="topTabs" aria-label="Main pages" style="margin-bottom:0;" id="appTabs">
          <a href="?page=config.html" data-page="config.html">Config</a>
          <a href="?page=diagnostics.html" data-page="diagnostics.html">Diagnostics</a>
          <a href="?page=alexa.html" data-page="alexa.html">Alexa</a>
          <a href="?page=library-health.html" data-page="library-health.html">Library Health</a>
          <a href="?page=queue-wizard.html" data-page="queue-wizard.html">Queue Wizard</a>
          <a href="?page=radio.html" data-page="radio.html">Radio</a>
          <a href="?page=podcasts.html" id="podcastsNavLink" data-page="podcasts.html">Podcasts</a>
        </nav>
        <button id="themeToggle" class="heroThemeToggle" type="button" title="Toggle light/dark theme" aria-label="Toggle theme" style="position:absolute;top:12px;right:16px;z-index:12;">ðŸŒ™</button>
      </div>
      <header>
        <div class="brand">
          <h1>Now Playing</h1>
          <div class="sub">moOde enhancement dashboard</div>
        </div>
      </header>
      <div class="heroTransportRow">
        <div id="heroTransport" class="heroTransport"><span class="muted">Now Playing Â· loadingâ€¦</span></div>
      </div>
      <div class="heroQueueCard" id="heroQueueCard">
        <div class="heroQueueHead">
          <div style="display:flex;align-items:center;gap:12px;flex-wrap:wrap;">
            <div class="heroQueueTitle">Current Queue</div>
            <label id="heroQueueArrowKeysWrap" style="display:inline-flex;align-items:center;gap:6px;color:#9fb1d9;font-size:12px;white-space:nowrap;">
              <input id="heroQueueArrowKeys" type="checkbox" />
              <span>activate keyboard arrow keys</span>
            </label>
          </div>
          <div id="heroQueueActionsHead" style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;justify-content:flex-end;">
            <button id="heroQueueSavePresets" class="heroQueueBtn" type="button" style="display:none;">Save queue as presets group</button>
            <button id="heroQueueClear" class="heroQueueBtn" type="button">Clear</button>
            <button id="heroQueueCrop" class="heroQueueBtn" type="button">Crop</button>
            <button id="heroQueueToggle" class="heroQueueBtn" type="button">Collapse</button>
          </div>
        </div>
        <div class="heroQueueNextUp" id="heroQueueNextUp"></div>
        <div class="heroQueueWrap" id="heroQueueWrap"><div class="heroQueueMeta">Loading queueâ€¦</div></div>
      </div>
    </div>
  </div>

  <div class="viewWrap" id="viewWrap">
    <iframe id="appFrame" title="Now Playing view" src="about:blank" scrolling="no" style="width:100%;display:block;"></iframe>
  </div>

  <div id="queueAlbumModal" class="queueAlbumModal" aria-hidden="true">
    <div class="queueAlbumCard" role="dialog" aria-modal="true" aria-label="Album details">
      <div class="queueAlbumHead">
        <div class="heroQueueTitle">Album details</div>
        <button id="queueAlbumClose" class="queueAlbumClose" type="button">Close</button>
      </div>
      <div id="queueAlbumBody" class="queueAlbumBody"></div>
    </div>
  </div>

  <script src="scripts/hero-transport.js?v=20260221-010"></script>
  <script src="scripts/theme-toggle.js?v=20260216-1"></script>
  <script>
    (() => {
      const VALID = new Set(['config.html','diagnostics.html','alexa.html','library-health.html','queue-wizard.html','radio.html','podcasts.html']);
      const frame = document.getElementById('appFrame');
      const viewWrap = document.getElementById('viewWrap');
      const tabs = Array.from(document.querySelectorAll('#appTabs a[data-page]'));

      function syncFrameWidth(){
        try {
          const heroWrap = document.querySelector('.heroWrap');
          const targetW = Math.max(320, Math.min(1080, Math.floor(heroWrap?.clientWidth || (window.innerWidth - 24))));
          if (viewWrap) viewWrap.style.width = `${targetW}px`;
          if (frame) frame.style.width = '100%';
        } catch {}
      }

      function normalizeEmbeddedDoc(){
        try {
          const doc = frame?.contentDocument;
          if (!doc) return;
          if (doc.getElementById('appShellNormalizeStyle')) return;
          const currentSrc = String(frame?.getAttribute('src') || '');
          const isConfig = currentSrc.includes('config.html');
          const isPodcasts = currentSrc.includes('podcasts.html');
          const isQueueWizard = currentSrc.includes('queue-wizard.html');
          const st = doc.createElement('style');
          st.id = 'appShellNormalizeStyle';
          st.textContent = [
            'html, body { margin: 0 !important; overflow-x: hidden !important; }',
            '.preHeroStatusWrap { display:none !important; }',
            '.heroRail { background: transparent !important; border: 0 !important; box-shadow: none !important; position: relative !important; top: auto !important; }',
            '.heroRail::before { content:none !important; display:none !important; }',
            '.heroRail .topTabs, .heroRail header, .heroRail .heroTransportRow, .heroRail #themeToggle { display:none !important; }',
            '.heroWrap, .wrap, .cfgWrap, .subsWrap { max-width: 100% !important; width: calc(100% - 16px) !important; margin: 0 auto !important; box-sizing: border-box !important; }',
            '.heroWrap { padding: 12px 8px 0 !important; background: transparent !important; border: 0 !important; box-shadow: none !important; }',
            '.wrap, .cfgWrap, .subsWrap { padding: 12px 8px 10px !important; }',
            '.panel { margin: 0 !important; padding-top: 8px !important; }',
            '.card, .cfgCard, .panel, .subsShell { box-sizing: border-box !important; }',
            (isConfig
              ? '.panel{background:transparent !important;border:0 !important;box-shadow:none !important;padding-top:0 !important;} .cfgWrap{padding-top:0 !important;} .tripleCards,.splitCards{grid-template-columns:repeat(2,minmax(320px,1fr)) !important;} .splitCardsRight{display:contents !important;}'
              : ''),
            (isQueueWizard
              ? '.heroRail,.heroWrap{display:none !important;}'
              : ''),
            (isPodcasts
              ? '.heroWrap{padding-top:10px !important;}'
              : '')
          ].join('\n');
          doc.head.appendChild(st);
        } catch {}
      }

      function syncFrameHeight(){
        try {
          if (!frame) return;
          const doc = frame.contentDocument;
          const win = frame.contentWindow;
          if (!doc || !win) return;
          normalizeEmbeddedDoc();
          const b = doc.body;
          const e = doc.documentElement;
          if (b) b.style.overflow = 'visible';
          if (e) e.style.overflow = 'visible';
          const contentH = Math.max(
            b ? b.scrollHeight : 0,
            b ? b.offsetHeight : 0,
            e ? e.scrollHeight : 0,
            e ? e.offsetHeight : 0,
            e ? e.clientHeight : 0
          );
          const measured = Math.max(contentH + 12, 480);
          const cur = Math.max(0, parseInt(String(frame.style.height || '0'), 10) || 0);
          const isQueueWizard = String(currentShellPage || '').includes('queue-wizard.html');
          // Prevent scroll jumps from iframe shrink/reflow in Queue Wizard: only grow while on that page.
          const next = isQueueWizard ? Math.max(cur, measured) : measured;
          frame.style.height = `${next}px`;
        } catch {}
      }

      function syncThemeToFrame(){
        try {
          if (!frame) return;
          const doc = frame.contentDocument;
          const win = frame.contentWindow;
          if (!doc || !win) return;
          const isLight = document.body?.classList.contains('theme-light');
          const t = isLight ? 'light' : 'dark';
          doc.documentElement?.classList.toggle('theme-light', isLight);
          doc.body?.classList.toggle('theme-light', isLight);
          if (doc.documentElement) doc.documentElement.style.background = isLight ? '#8e79b6' : '#0c1526';
          try { win.localStorage.setItem('np-theme', t); } catch {}
          try { win.postMessage({ type: 'np-theme-sync', theme: t }, '*'); } catch {}
        } catch {}
      }

      function setPillState(pillId, state){
        const map = { ok:{c:'#22c55e',b:'rgba(34,197,94,.55)'}, warn:{c:'#f59e0b',b:'rgba(245,158,11,.55)'}, bad:{c:'#ef4444',b:'rgba(239,68,68,.55)'}, off:{c:'#64748b',b:'rgba(100,116,139,.45)'} };
        const s = map[state] || map.off;
        const pill = document.getElementById(pillId); if (!pill) return;
        const dot = pill.querySelector('.dot');
        if (dot) { dot.style.background = s.c; dot.style.boxShadow = `0 0 0 6px ${s.b.replace('.55','.20')}`; }
        pill.style.borderColor = s.b;
      }

      let runtimeTrackKey = '';
      let radioStationByKey = new Map();
      let radioStationByHost = new Map();
      let radioHostAmbiguous = new Set();
      let radioHostMapTs = 0;
      let lastHeroQueueSignature = '';
      let currentShellPage = getPageFromUrl();
      let lastRadioPresetStations = [];
      const RADIO_QUEUE_PRESETS_KEY = 'nowplaying.radioQueuePresets.v1';

      async function sendHeroPlayback(action, extra = null){
        const host = location.hostname || '10.0.0.233';
        const base = `${location.protocol}//${host}:3101`;
        if (!runtimeTrackKey) {
          const rr = await fetch(`${base}/config/runtime`, { cache:'no-store' });
          const rj = await rr.json().catch(() => ({}));
          runtimeTrackKey = String(rj?.config?.trackKey || '').trim();
        }
        const payload = Object.assign({ action }, extra || {});
        const r = await fetch(`${base}/config/diagnostics/playback`, {
          method:'POST',
          headers:{ 'Content-Type':'application/json', ...(runtimeTrackKey ? { 'x-track-key': runtimeTrackKey } : {}) },
          body: JSON.stringify(payload),
        });
        const j = await r.json().catch(() => ({}));
        if (!r.ok || !j?.ok) throw new Error(j?.error || `HTTP ${r.status}`);
        return j;
      }

      function streamKey(u){
        try {
          const x = new URL(String(u || ''));
          const hp = `${String(x.hostname||'').toLowerCase()}${x.port ? `:${x.port}` : ''}`;
          return `${hp}${String(x.pathname||'')}`.replace(/\/+$/, '');
        } catch { return ''; }
      }

      async function loadRadioHostNameMap(base, headers = {}) {
        const now = Date.now();
        if (radioStationByKey.size && (now - radioHostMapTs) < (5 * 60 * 1000)) {
          return { byKey: radioStationByKey, byHost: radioStationByHost, ambHosts: radioHostAmbiguous };
        }
        try {
          const r = await fetch(`${base}/config/queue-wizard/radio-preview`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', ...(headers || {}) },
            body: JSON.stringify({ genres: [], favoritesOnly: false, hqOnly: false, favoriteStations: [], maxStations: 1000 }),
          });
          const j = await r.json().catch(() => ({}));
          if (!r.ok || !j?.ok) return { byKey: radioStationByKey, byHost: radioStationByHost, ambHosts: radioHostAmbiguous };
          const byKey = new Map();
          const byHost = new Map();
          const ambHosts = new Set();
          for (const t of (Array.isArray(j.tracks) ? j.tracks : [])) {
            const file = String(t?.file || '').trim();
            const st = String(t?.stationName || t?.artist || '').trim();
            if (!file || !st) continue;
            const k = streamKey(file);
            if (k) byKey.set(k, st);
            try {
              const h = String(new URL(file).hostname || '').toLowerCase();
              if (h) {
                if (!byHost.has(h)) byHost.set(h, st);
                else if (byHost.get(h) !== st) ambHosts.add(h);
              }
            } catch {}
          }
          radioStationByKey = byKey;
          radioStationByHost = byHost;
          radioHostAmbiguous = ambHosts;
          radioHostMapTs = now;
        } catch {}
        return { byKey: radioStationByKey, byHost: radioStationByHost, ambHosts: radioHostAmbiguous };
      }

      function updateSavePresetsButtonVisibility(){
        const btn = document.getElementById('heroQueueSavePresets');
        if (!btn) return;
        const onRadioTab = String(currentShellPage || '') === 'radio.html';
        const hasStations = Array.isArray(lastRadioPresetStations) && lastRadioPresetStations.length > 0;
        btn.style.display = (!queueCollapsed && onRadioTab && hasStations) ? '' : 'none';
      }

      async function saveCurrentQueueAsRadioPreset(){
        const stations = Array.isArray(lastRadioPresetStations) ? lastRadioPresetStations : [];
        if (!stations.length) return;
        const d = new Date();
        const def = `Radio preset ${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')} ${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`;
        const name = String(window.prompt('Preset name:', def) || '').trim();
        if (!name) return;

        // Primary: persist server-side for reliability across browser/profile restarts.
        try {
          const host = location.hostname || '10.0.0.233';
          const base = `${location.protocol}//${host}:3101`;
          if (!runtimeTrackKey) {
            const rr = await fetch(`${base}/config/runtime`, { cache:'no-store' });
            const rj = await rr.json().catch(() => ({}));
            runtimeTrackKey = String(rj?.config?.trackKey || '').trim();
          }
          const r = await fetch(`${base}/config/queue-wizard/radio-presets`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              ...(runtimeTrackKey ? { 'x-track-key': runtimeTrackKey } : {}),
            },
            body: JSON.stringify({ name, stations }),
          });
          const j = await r.json().catch(() => ({}));
          if (!r.ok || !j?.ok) throw new Error(j?.error || `HTTP ${r.status}`);
        } catch {
          // Fallback: localStorage (legacy behavior)
          let list = [];
          try { list = JSON.parse(localStorage.getItem(RADIO_QUEUE_PRESETS_KEY) || '[]'); } catch {}
          if (!Array.isArray(list)) list = [];
          const entry = {
            id: `rp_${Date.now()}_${Math.random().toString(36).slice(2,8)}`,
            name,
            createdAt: Date.now(),
            stations: stations,
          };
          list.unshift(entry);
          if (list.length > 30) list = list.slice(0, 30);
          try { localStorage.setItem(RADIO_QUEUE_PRESETS_KEY, JSON.stringify(list)); } catch {}
        }

        try { frame.contentWindow?.postMessage({ type: 'radio-presets-updated' }, '*'); } catch {}
      }

      async function syncHeroQueue(){

        try {
          if (document.hidden) return;
          const host = location.hostname || '10.0.0.233';
          const base = `${location.protocol}//${host}:3101`;
          const wrap = document.getElementById('heroQueueWrap');
          if (!wrap) return;

          if (!runtimeTrackKey) {
            const rr = await fetch(`${base}/config/runtime`, { cache:'no-store' });
            const rj = await rr.json().catch(() => ({}));
            runtimeTrackKey = String(rj?.config?.trackKey || '').trim();
          }

          const headers = runtimeTrackKey ? { 'x-track-key': runtimeTrackKey } : {};
          const radioMapP = loadRadioHostNameMap(base, headers);
          const [r, npRes, nextUpRes, awRes, radioMap] = await Promise.all([
            fetch(`${base}/config/diagnostics/queue`, { cache:'no-store', headers }),
            fetch(`${base}/now-playing`, { cache:'no-store', headers }).catch(() => null),
            fetch(`${base}/next-up`, { cache:'no-store', headers }).catch(() => null),
            fetch(`${base}/alexa/was-playing`, { cache:'no-store', headers }).catch(() => null),
            radioMapP,
          ]);
          const j = await r.json().catch(() => ({}));
          let np = npRes ? await npRes.json().catch(() => ({})) : {};
          const nextUpApi = nextUpRes ? await nextUpRes.json().catch(() => ({})) : {};
          const aw = awRes ? await awRes.json().catch(() => ({})) : {};
          if (!r.ok || !j?.ok) throw new Error(j?.error || `HTTP ${r.status}`);

          // Honor Alexa mode sensor payload when active/fresh so hero reflects Alexa-driven playback.
          try {
            const awNp = aw?.nowPlaying || null;
            const awWp = aw?.wasPlaying || null;
            const awFresh = !!aw?.fresh;
            const awActive = !!((awNp && awNp.active) || (awWp && awWp.active));
            const awPayload = (awNp && awNp.file) ? awNp : ((awWp && awWp.file) ? awWp : null);
            if (awFresh && awActive && awPayload) {
              np = { ...np, ...awPayload, alexaMode: true };
            }
          } catch {}

          const fallbackStation = String(np?.stationName || np?._stationName || np?.radioStationName || '').trim();
          const fallbackNowArtRaw = String(np?.albumArtUrl || np?.altArtUrl || '').trim();
          const fallbackNowArt = fallbackNowArtRaw ? (fallbackNowArtRaw.startsWith('http') ? fallbackNowArtRaw : `${base}${fallbackNowArtRaw}`) : '';
          const alexaHintText = String(np?.subline || np?.liveLabel || '').toLowerCase();
          const heroAlexaText = String(document.getElementById('heroTransport')?.textContent || '').toLowerCase();
          const isAlexaMode = !!np?.alexaMode || !!nextUpApi?.alexaMode || alexaHintText.includes('alexa mode') || heroAlexaText.includes('alexa mode');
          const nowIsAirplay = !!np?.isAirplay;
          const items = (Array.isArray(j.items) ? j.items : []).map((it, idx) => {
            const p = Number.isFinite(Number(it?.pos)) ? Number(it.pos)
              : (Number.isFinite(Number(it?.position)) ? Number(it.position) : (idx + 1));
            return { ...it, _posDisplay: p };
          });
          const presetStations = [];
          if (!items.length) {
            const emptySig = 'empty';
            if (lastHeroQueueSignature !== emptySig) {
              wrap.innerHTML = '<div class="heroQueueMeta">Queue is empty.</div>';
              lastHeroQueueSignature = emptySig;
            }
            lastRadioPresetStations = [];
            if (hqNextUp) hqNextUp.innerHTML = '<div class="heroQueueMeta">Next-up: none</div>';
            updateSavePresetsButtonVisibility();
            return;
          }
          const headPosNum = Number(j.headPos || -1);
          let headIdx = items.findIndex((x) => Number(x?._posDisplay || 0) === headPosNum);
          if (headIdx < 0) headIdx = items.findIndex((x) => !!x?.isHead);
          const nextItem = (headIdx >= 0 && headIdx < (items.length - 1)) ? items[headIdx + 1] : null;
          if (hqNextUp) {
            const headItem = (headIdx >= 0) ? items[headIdx] : (items[0] || null);
            if (isAlexaMode && headItem) {
              const hf = String(headItem?.file || '').trim();
              const hStream = /^https?:\/\//i.test(hf);
              const hThumbRaw = String(headItem?.thumbUrl || '').trim();
              const hThumb = hThumbRaw
                ? (hThumbRaw.startsWith('http') ? hThumbRaw : `${base}${hThumbRaw}`)
                : fallbackNowArt;
              const hName = hStream
                ? String(headItem?.stationName || headItem?.name || headItem?.artist || fallbackStation || 'Radio station').trim()
                : String(headItem?.artist || headItem?.name || '').trim();
              const hTitle = hStream ? '' : String(headItem?.title || '').trim();
              const hText = hTitle ? `${hName} â€¢ ${hTitle}` : (hName || String(np?.title || '').trim() || '(unknown)');
              hqNextUp.innerHTML = `${hThumb ? `<img src="${hThumb}" alt="">` : ''}<div class="heroQueueMeta">Next-up: ${hText}</div>`;
            } else {
              const apiNext = (nextUpApi && nextUpApi.ok && nextUpApi.next) ? nextUpApi.next : null;
              if (apiNext) {
                const aArtist = String(apiNext.artist || '').trim();
                const aTitle = String(apiNext.title || '').trim() || String(apiNext.file || '').trim();
                const aArtRaw = String(apiNext.artUrl || '').trim();
                const aArt = aArtRaw ? (aArtRaw.startsWith('http') ? aArtRaw : `${base}${aArtRaw}`) : '';
                const txt = [aArtist, aTitle].filter(Boolean).join(' â€¢ ') || '(unknown)';
                hqNextUp.innerHTML = `${aArt ? `<img src="${aArt}" alt="">` : ''}<div class="heroQueueMeta">Next-up: ${txt}</div>`;
              } else if (!nextItem) {
                hqNextUp.innerHTML = '<div class="heroQueueMeta">Next-up: none</div>';
              } else {
                const nf = String(nextItem?.file || '').trim();
                const nStream = /^https?:\/\//i.test(nf);
                const nThumbRaw = String(nextItem?.thumbUrl || '').trim();
                const nThumb = nThumbRaw ? (nThumbRaw.startsWith('http') ? nThumbRaw : `${base}${nThumbRaw}`) : '';
                const nName = nStream
                  ? String(nextItem?.stationName || nextItem?.name || nextItem?.artist || 'Radio station').trim()
                  : String(nextItem?.artist || nextItem?.name || '').trim();
                const nTitle = nStream ? '' : String(nextItem?.title || '').trim();
                const nText = nTitle ? `${nName} â€¢ ${nTitle}` : nName;
                hqNextUp.innerHTML = `${nThumb ? `<img src="${nThumb}" alt="">` : ''}<div class="heroQueueMeta">Next-up: ${nText || '(unknown)'}</div>`;
              }
            }

            if (queueCollapsed && hqBtn) {
              hqNextUp.appendChild(hqBtn);
              hqBtn.style.marginLeft = 'auto';
            }
          }

          if (queueCollapsed) {
            const collapsedSig = JSON.stringify({
              c: true,
              state: String(j.playbackState || ''),
              count: items.length,
              head: Number(j.headPos || -1),
              next: String(nextUpApi?.next?.file || nextUpApi?.next?.title || ''),
            });
            if (lastHeroQueueSignature === collapsedSig) return;
            lastHeroQueueSignature = collapsedSig;
            if (hqWrap) hqWrap.innerHTML = '';
            lastRadioPresetStations = [];
            updateSavePresetsButtonVisibility();
            return;
          }

          const queueSig = JSON.stringify({
            state: String(j.playbackState || ''),
            count: items.length,
            head: Number(j.headPos || -1),
            items: items.map((x) => [
              Number(x?._posDisplay || 0),
              !!x?.isHead,
              String(x?.artist || ''),
              String(x?.title || ''),
              String(x?.thumbUrl || ''),
              String(x?.file || ''),
            ])
          });
          if (lastHeroQueueSignature === queueSig) return;
          lastHeroQueueSignature = queueSig;

          const existingIconByFile = new Map();
          try {
            wrap.querySelectorAll('.heroQueueRow[data-queue-file]').forEach((row) => {
              const fEnc = String(row.getAttribute('data-queue-file') || '');
              const img = row.querySelector('img');
              const src = String(img?.getAttribute('src') || '').trim();
              if (!fEnc || !src) return;
              let f = '';
              try { f = decodeURIComponent(fEnc); } catch { f = fEnc; }
              if (f) existingIconByFile.set(f, src);
            });
          } catch {}

          wrap.innerHTML = items.map((x) => {
            const pos = Number(x?._posDisplay || 0);
            const head = !!x?.isHead;
            const thumbRaw = String(x?.thumbUrl || '').trim();
            const fileRaw = String(x?.file || '').trim();
            const isStreamish = /^https?:\/\//i.test(fileRaw);
            const stationName = String(x?.name || x?.stationName || '').trim();
            let derivedStation = '';
            let derivedHost = '';
            if (isStreamish && fileRaw) {
              try {
                const u = new URL(fileRaw);
                derivedHost = String(u.hostname || '').toLowerCase();
                derivedStation = String(u.hostname || '').replace(/^www\./i, '').trim();
              } catch {}
            }
            const derivedKey = streamKey(fileRaw);
            const mappedByKey = (derivedKey && radioMap?.byKey && typeof radioMap.byKey.get === 'function') ? String(radioMap.byKey.get(derivedKey) || '').trim() : '';
            const hostAmb = !!(derivedHost && radioMap?.ambHosts && typeof radioMap.ambHosts.has === 'function' && radioMap.ambHosts.has(derivedHost));
            const mappedByHost = (derivedHost && radioMap?.byHost && typeof radioMap.byHost.get === 'function') ? String(radioMap.byHost.get(derivedHost) || '').trim() : '';
            const stationLooksHost = !!(stationName && /\./.test(stationName) && !/\s/.test(stationName));
            const displayStation = (!stationLooksHost ? stationName : '') || mappedByKey || mappedByHost || stationName || (head ? fallbackStation : '') || derivedStation;
            if (isStreamish && fileRaw) {
              presetStations.push({ file: fileRaw, stationName: String(displayStation || stationName || '').trim() });
            }
            const artistRaw = String(x?.artist || '').trim();
            const looksIheartBlob = /\btext="[^"]+"|\bsong_spot="[^"]+"|\bspEventID="[^"]+"|\bTPID="\d+"/i.test(artistRaw);
            const iheartText = (artistRaw.match(/\btext="([^"]+)"/i) || [])[1] || '';
            const artistClean = looksIheartBlob ? '' : artistRaw;
            const artist = (isStreamish
              ? (displayStation || stationName || derivedStation || 'Radio station')
              : (artistClean || String(x?.name || '').trim() || '(unknown)'));
            const titleRaw = String(x?.title || '').trim().replace(/\s*\[\d{1,4}\]\s*$/,'').trim();
            const title = isStreamish ? '' : titleRaw;
            const hostFavicon = derivedHost ? `https://icons.duckduckgo.com/ip3/${encodeURIComponent(derivedHost)}.ico` : '';
            const hostFaviconAlt = derivedHost ? `https://www.google.com/s2/favicons?domain=${encodeURIComponent(derivedHost)}&sz=64` : '';
            const logoName = ((!stationLooksHost ? stationName : '') || displayStation || stationName || '').trim();
            const logoNameAlt = logoName
              ? logoName
                  .replace(/\s*\([^)]*\)\s*/g, ' ')
                  .replace(/\s*:\s*/g, ' - ')
                  .replace(/\s{2,}/g, ' ')
                  .trim()
              : '';
            const stationLogoByDisplay = logoName ? `${base}/art/radio-logo.jpg?name=${encodeURIComponent(logoName)}` : '';
            const stationLogoByDisplayAlt = (logoNameAlt && logoNameAlt !== logoName) ? `${base}/art/radio-logo.jpg?name=${encodeURIComponent(logoNameAlt)}` : '';
            const stationLogoByFile = fileRaw ? `${base}/art/radio-logo.jpg?file=${encodeURIComponent(fileRaw)}` : '';
            let thumb = '';
            if (isStreamish) {
              // Queue card policy: for stream/radio rows, always use station branding (never album art).
              const cachedIcon = String(existingIconByFile.get(fileRaw) || '').trim();
              thumb = cachedIcon || stationLogoByDisplay || stationLogoByDisplayAlt || stationLogoByFile || hostFavicon || hostFaviconAlt || '';
            } else {
              thumb = thumbRaw ? (thumbRaw.startsWith('http') ? thumbRaw : `${base}${thumbRaw}`) : '';
              if (!thumb && nowIsAirplay && fallbackNowArt) thumb = fallbackNowArt;
              if (thumb && /\/art\/current\.jpg(?:$|\?)/i.test(thumb)) {
                const stableBust = encodeURIComponent(String(fileRaw || titleRaw || pos || '').trim());
                if (stableBust) thumb += (thumb.includes('?') ? '&' : '?') + `k=${stableBust}`;
              }
            }
            const fallbackIcon = `data:image/svg+xml;utf8,${encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="4" y="4" width="56" height="56" rx="10" fill="#0a1222" stroke="#3b4f72"/><circle cx="32" cy="32" r="6" fill="#8fb3ff"/><path d="M32 26V14M32 50V38M26 32H14M50 32H38" stroke="#8fb3ff" stroke-width="4" stroke-linecap="round"/></svg>')}`;
            const fallbackJs = `if(this.dataset.step!=='1' && '${stationLogoByDisplay}') { this.dataset.step='1'; this.src='${stationLogoByDisplay}'; return; } if(this.dataset.step!=='2' && '${stationLogoByDisplayAlt}') { this.dataset.step='2'; this.src='${stationLogoByDisplayAlt}'; return; } if(this.dataset.step!=='3' && '${stationLogoByFile}') { this.dataset.step='3'; this.src='${stationLogoByFile}'; return; } if(this.dataset.step!=='4' && '${hostFavicon}') { this.dataset.step='4'; this.src='${hostFavicon}'; return; } if(this.dataset.step!=='5' && '${hostFaviconAlt}') { this.dataset.step='5'; this.src='${hostFaviconAlt}'; return; } this.src='${fallbackIcon}';`;
            const thumbHtml = thumb
              ? `<img loading="lazy" decoding="async" fetchpriority="low" src="${thumb}" alt="" onerror="${fallbackJs}" style="width:34px;height:34px;border-radius:7px;object-fit:cover;border:1px solid #334;background:#0a1222;" />`
              : `<img loading="lazy" decoding="async" fetchpriority="low" src="${stationLogoByDisplay || stationLogoByDisplayAlt || stationLogoByFile || hostFavicon || hostFaviconAlt || fallbackIcon}" alt="" onerror="${fallbackJs}" style="width:34px;height:34px;border-radius:7px;object-fit:cover;border:1px solid #334;background:#0a1222;" />`;
            const actions = `<div class="heroQueueActions"><button type="button" data-move-pos="${pos}" data-move-dir="up" title="Move up">â†‘</button><button type="button" data-move-pos="${pos}" data-move-dir="down" title="Move down">â†“</button><button type="button" data-remove-pos="${pos}" title="Remove">Remove</button></div>`;
            const albumTxt = String(x?.album || '').trim();
            const rating = Math.max(0, Math.min(5, Number(x?.rating || 0)));
            const starsInline = isStreamish
              ? ''
              : `<span style="margin-left:8px;letter-spacing:1px;font-size:14px;white-space:nowrap;">${'<span style="color:#fbbf24;">â˜…</span>'.repeat(rating)}${'<span style="color:#64748b;">â˜…</span>'.repeat(5 - rating)}</span>`;
            const line1 = isStreamish ? (artist || '(station)') : (title || '(unknown title)');
            const line2 = isStreamish
              ? ''
              : (albumTxt
                ? `<div class="heroQueueMeta">${artist || '(unknown artist)'} â€¢ <button type="button" class="queueAlbumLineBtn" data-queue-album="${encodeURIComponent(albumTxt)}" data-queue-artist="${encodeURIComponent(artist)}" data-queue-title="${encodeURIComponent(title)}" data-queue-art="${encodeURIComponent(thumb || '')}">${albumTxt}</button></div>`
                : `<div class="heroQueueMeta">${artist || '(unknown artist)'}</div>`);
            return `<div class="heroQueueRow" data-queue-play-pos="${pos}" data-queue-file="${encodeURIComponent(fileRaw)}" style="cursor:pointer;${head ? 'background:rgba(34,197,94,.14);border-radius:8px;' : ''}">${thumbHtml}<div><b>${pos}</b>${head?' â–¶':''}</div><div style="min-width:0;flex:1 1 auto;"><div style="display:flex;align-items:center;gap:6px;min-width:0;"><span style="font-size:16px;font-weight:600;min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${line1}</span>${starsInline}</div>${line2}</div>${actions}</div>`;
          }).join('');

          const onlyRadioStations = !!items.length && items.every((x) => {
            const f = String(x?.file || '').trim();
            const streamish = /^https?:\/\//i.test(f);
            return streamish && !x?.isPodcast;
          });
          lastRadioPresetStations = onlyRadioStations
            ? Array.from(new Map(presetStations.filter((s) => !!s?.file).map((s) => [String(s.file), s])).values())
            : [];
          updateSavePresetsButtonVisibility();
        } catch (e) {
          const wrap = document.getElementById('heroQueueWrap');
          if (wrap) wrap.innerHTML = `<div class="heroQueueMeta">Queue load failed: ${String(e?.message || e)}</div>`;
          lastRadioPresetStations = [];
          updateSavePresetsButtonVisibility();
        }
      }

      async function syncPills(){
        try {
          const host = location.hostname || '10.0.0.233';
          const base = `${location.protocol}//${host}:3101`;
          const r = await fetch(`${base}/config/runtime`, { cache:'no-store' });
          const j = await r.json().catch(() => ({}));
          if (!r.ok || !j?.ok) throw new Error('runtime unavailable');
          const cfg = j.config || {};
          const ports = cfg.ports || {};
          const apiPort = Number(ports.api || 3101);
          const uiPort = Number(ports.ui || 8101);
          const axEnabled = !!cfg?.alexa?.enabled;
          const axDomain = String(cfg?.alexa?.publicDomain || '').trim();
          const moodeHost = String(cfg?.moode?.sshHost || cfg?.mpd?.host || cfg?.mpdHost || '').trim();

          const $ = (id) => document.getElementById(id);
          if ($('apiHint')) $('apiHint').textContent = `${host}:${apiPort}`;
          if ($('webHint')) $('webHint').textContent = `${host}:${uiPort}`;
          if ($('alexaHint')) $('alexaHint').textContent = !axEnabled ? 'disabled' : (axDomain ? 'moode.â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢.com' : 'missing domain');
          if ($('moodeHint')) $('moodeHint').textContent = moodeHost ? `confirmed (${moodeHost})` : 'not verified';
          setPillState('apiPill','ok');
          setPillState('webPill','ok');
          setPillState('alexaPill', !axEnabled ? 'off' : (axDomain ? 'ok' : 'warn'));
          setPillState('moodePill', moodeHost ? 'ok' : 'warn');

          const podcastsLink = document.getElementById('podcastsNavLink');
          if (podcastsLink && !cfg?.features?.podcasts) podcastsLink.style.display = 'none';
        } catch {
          setPillState('apiPill','bad');
          setPillState('webPill','warn');
          setPillState('alexaPill','warn');
          setPillState('moodePill','warn');
        }
      }

      function getPageFromUrl() {
        const u = new URL(location.href);
        const p = String(u.searchParams.get('page') || 'config.html').trim();
        return VALID.has(p) ? p : 'config.html';
      }

      function setActive(page){
        tabs.forEach((a) => a.classList.toggle('active', a.dataset.page === page));
      }

      function navigate(page, push = true){
        const safe = VALID.has(page) ? page : 'config.html';
        currentShellPage = safe;
        setActive(safe);
        updateSavePresetsButtonVisibility();
        const src = `${safe}${safe.includes('?') ? '&' : '?'}shellts=${Date.now()}`;
        frame.setAttribute('src', src);
        if (push) {
          const u = new URL(location.href);
          u.searchParams.set('page', safe);
          history.pushState({ page: safe }, '', u);
        }
        setTimeout(syncFrameHeight, 120);
        setTimeout(syncFrameHeight, 500);
      }

      tabs.forEach((a) => a.addEventListener('click', (ev) => {
        ev.preventDefault();
        navigate(a.dataset.page || 'config.html', true);
      }));

      window.addEventListener('popstate', () => navigate(getPageFromUrl(), false));
      window.addEventListener('resize', () => { syncFrameWidth(); syncFrameHeight(); });
      frame.addEventListener('load', () => {
        syncFrameWidth();
        syncFrameHeight();
        syncThemeToFrame();
        setTimeout(syncFrameHeight, 250);
        setTimeout(syncFrameHeight, 900);
        setTimeout(syncThemeToFrame, 120);
      });

      document.getElementById('themeToggle')?.addEventListener('click', () => {
        setTimeout(syncThemeToFrame, 0);
        setTimeout(syncThemeToFrame, 120);
      });

      const hqBtn = document.getElementById('heroQueueToggle');
      const hqClear = document.getElementById('heroQueueClear');
      const hqCrop = document.getElementById('heroQueueCrop');
      const hqSave = document.getElementById('heroQueueSavePresets');
      const hqWrap = document.getElementById('heroQueueWrap');
      const hqNextUp = document.getElementById('heroQueueNextUp');
      const hqActionsHead = document.getElementById('heroQueueActionsHead');
      const hqArrowWrap = document.getElementById('heroQueueArrowKeysWrap');
      const queueAlbumModal = document.getElementById('queueAlbumModal');
      const queueAlbumBody = document.getElementById('queueAlbumBody');
      const queueAlbumClose = document.getElementById('queueAlbumClose');

      function markQueueRowActiveOptimistic(position){
        const wrap = document.getElementById('heroQueueWrap');
        if (!wrap) return;
        const target = Number(position || 0);
        if (!Number.isFinite(target) || target <= 0) return;
        wrap.querySelectorAll('.heroQueueRow[data-queue-play-pos]').forEach((row) => {
          const p = Number(row.getAttribute('data-queue-play-pos') || 0);
          if (p === target) {
            row.style.background = 'rgba(34,197,94,.14)';
            row.style.borderRadius = '8px';
          } else {
            row.style.background = '';
            row.style.borderRadius = '';
          }
        });
      }

      function setQueueBusyHint(msg = ''){
        const el = document.querySelector('.heroQueueTitle');
        if (!el) return;
        const base = 'Current Queue';
        el.textContent = msg ? `${base} Â· ${msg}` : base;
      }

      function closeQueueAlbumModal(){
        if (!queueAlbumModal) return;
        queueAlbumModal.classList.remove('open');
        queueAlbumModal.setAttribute('aria-hidden', 'true');
      }

      async function ensureTrackKey(base){
        if (runtimeTrackKey) return runtimeTrackKey;
        const rr = await fetch(`${base}/config/runtime`, { cache:'no-store' });
        const rj = await rr.json().catch(() => ({}));
        runtimeTrackKey = String(rj?.config?.trackKey || '').trim();
        return runtimeTrackKey;
      }

      async function openArtistAlbumsModal({ artist = '' } = {}){
        if (!queueAlbumModal || !queueAlbumBody) return;
        const artistTxt = String(artist || '').trim();
        if (!artistTxt) return;
        const host = location.hostname || '10.0.0.233';
        const base = `${location.protocol}//${host}:3101`;

        queueAlbumBody.innerHTML = `<div class="queueAlbumMeta" style="grid-column:1 / -1;">`
          + `<div class="queueAlbumTitle">${artistTxt}</div>`
          + `<div class="queueAlbumSub">Loading albumsâ€¦</div>`
          + `<div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-top:6px;">`
          + `<button type="button" class="queueAlbumClose" data-artist-action="shuffle" data-artist="${encodeURIComponent(artistTxt)}">Shuffle all</button>`
          + `<label class="queueAlbumSub" style="display:inline-flex;align-items:center;gap:6px;margin:0;">min rating`
          + `<select id="queueArtistMinRating" style="min-width:116px;">`
          + `<option value="0">Any</option>`
          + `<option value="1">1â˜…+</option>`
          + `<option value="2" selected>2â˜…+</option>`
          + `<option value="3">3â˜…+</option>`
          + `<option value="4">4â˜…+</option>`
          + `<option value="5">5â˜…</option>`
          + `</select></label>`
          + `</div></div>`;

        queueAlbumModal.classList.add('open');
        queueAlbumModal.setAttribute('aria-hidden', 'false');

        try {
          await ensureTrackKey(base);
          const q = new URLSearchParams({ artist: artistTxt });
          const r = await fetch(`${base}/config/diagnostics/artist-albums?${q.toString()}`, { cache:'no-store', headers: { ...(runtimeTrackKey ? { 'x-track-key': runtimeTrackKey } : {}) } });
          const j = await r.json().catch(() => ({}));
          if (!r.ok || !j?.ok) throw new Error(j?.error || `HTTP ${r.status}`);
          const albums = Array.isArray(j.albums) ? j.albums : [];
          const grid = albums.length
            ? `<div class="queueArtistGrid">${albums.map((a) => {
                const alb = String(a?.album || '').trim();
                const sf = String(a?.sampleFile || '').trim();
                const art = sf ? `${base}/art/track_640.jpg?file=${encodeURIComponent(sf)}` : '';
                return `<button type="button" class="queueArtistAlbumBtn" data-open-album="${encodeURIComponent(alb)}" data-open-artist="${encodeURIComponent(artistTxt)}" data-open-art="${encodeURIComponent(art)}">`
                  + `${art ? `<img src="${art}" alt="">` : ''}`
                  + `<div class="queueArtistAlbumName">${alb || '(unknown album)'}</div>`
                  + `</button>`;
              }).join('')}</div>`
            : `<div class="queueAlbumSub" style="grid-column:1 / -1;">No albums found for this artist.</div>`;
          queueAlbumBody.innerHTML = queueAlbumBody.innerHTML.replace('Loading albumsâ€¦', `${albums.length} album(s)`) + grid;
        } catch (e) {
          queueAlbumBody.innerHTML = queueAlbumBody.innerHTML.replace('Loading albumsâ€¦', `Failed to load albums: ${String(e?.message || e)}`);
        }
      }

      async function openQueueAlbumModal({ album = '', artist = '', title = '', art = '' } = {}){
        if (!queueAlbumModal || !queueAlbumBody) return;
        const host = location.hostname || '10.0.0.233';
        const base = `${location.protocol}//${host}:3101`;
        const albumTxt = String(album || '').trim() || '(unknown album)';
        const artistTxt = String(artist || '').trim();
        const titleTxt = String(title || '').trim();
        const artUrl = String(art || '').trim();

        queueAlbumBody.innerHTML =
          `${artUrl ? `<img src="${artUrl}" alt="">` : '<div style="width:120px;height:120px;border-radius:10px;border:1px solid #334;background:#0a1222"></div>'}` +
          `<div class="queueAlbumMeta">` +
            `<div class="queueAlbumTitle">${albumTxt}</div>` +
            `${artistTxt ? `<div class="queueAlbumSub">Artist: <button type="button" class="queueAlbumLineBtn" data-open-artist-albums="${encodeURIComponent(artistTxt)}">${artistTxt}</button></div>` : ''}` +
            `<div class="queueAlbumSub">Loading album tracksâ€¦</div>` +
            `<div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:6px;">` +
              `<button type="button" class="queueAlbumClose" data-album-action="append" data-album="${encodeURIComponent(albumTxt)}" data-artist="${encodeURIComponent(artistTxt)}">Append album</button>` +
              `<button type="button" class="queueAlbumClose" data-album-action="crop" data-album="${encodeURIComponent(albumTxt)}" data-artist="${encodeURIComponent(artistTxt)}">Add album (crop)</button>` +
              `<button type="button" class="queueAlbumClose" data-album-action="replace" data-album="${encodeURIComponent(albumTxt)}" data-artist="${encodeURIComponent(artistTxt)}">Replace with album</button>` +
            `</div>` +
            `${titleTxt ? `<div class="queueAlbumSub">From track: ${titleTxt}</div>` : ''}` +
          `</div>`;
        queueAlbumModal.classList.add('open');
        queueAlbumModal.setAttribute('aria-hidden', 'false');

        try {
          await ensureTrackKey(base);
          const q = new URLSearchParams({ album: albumTxt });
          if (artistTxt) q.set('artist', artistTxt);
          const r = await fetch(`${base}/config/diagnostics/album-tracks?${q.toString()}`, {
            cache:'no-store',
            headers: { ...(runtimeTrackKey ? { 'x-track-key': runtimeTrackKey } : {}) }
          });
          const j = await r.json().catch(() => ({}));
          if (!r.ok || !j?.ok) throw new Error(j?.error || `HTTP ${r.status}`);
          const tracks = Array.isArray(j.tracks) ? j.tracks : [];
          const listHtml = tracks.length
            ? `<div class="queueAlbumTracks">${tracks.map((t, idx) => {
                const tr = String(t?.track || '').trim();
                const tt = String(t?.title || '').trim() || '(untitled)';
                const tf = String(t?.file || '').trim();
                return `<div class="queueAlbumTrackRow">`
                  + `<div class="queueAlbumTrackNum">${tr || (idx+1)}</div>`
                  + `<div class="queueAlbumTrackTitle">${tt}</div>`
                  + `<div class="queueAlbumTrackActions">`
                  + `<button type="button" class="queueAlbumClose queueAlbumTrackBtn" data-track-action="play" data-track-file="${encodeURIComponent(tf)}">Play now</button>`
                  + `<button type="button" class="queueAlbumClose queueAlbumTrackBtn" data-track-action="add" data-track-file="${encodeURIComponent(tf)}">Add</button>`
                  + `</div></div>`;
              }).join('')}</div>`
            : `<div class="queueAlbumSub" style="margin-top:8px;">No tracks found for this album.</div>`;
          queueAlbumBody.innerHTML = queueAlbumBody.innerHTML.replace('<div class="queueAlbumSub">Loading album tracksâ€¦</div>', `<div class="queueAlbumSub">${tracks.length} track(s)</div>`) + listHtml;
        } catch (e) {
          queueAlbumBody.innerHTML = queueAlbumBody.innerHTML.replace('<div class="queueAlbumSub">Loading album tracksâ€¦</div>', `<div class="queueAlbumSub">Failed to load tracks: ${String(e?.message || e)}</div>`);
        }
      }

      function queueRefreshBurst(){
        try { syncHeroQueue(); } catch {}
        try { setTimeout(() => { try { syncHeroQueue(); } catch {} }, 220); } catch {}
        try { setTimeout(() => { try { syncHeroQueue(); } catch {} }, 700); } catch {}
      }

      window.addEventListener('openclaw:hero-open-album-modal', async (ev) => {
        const d = ev?.detail || {};
        const album = String(d.album || '').trim();
        const artist = String(d.artist || '').trim();
        const art = String(d.art || '').trim();
        if (!album) return;
        try { await openQueueAlbumModal({ album, artist, art }); } catch {}
      });

      queueAlbumClose?.addEventListener('click', closeQueueAlbumModal);
      queueAlbumModal?.addEventListener('click', async (ev) => {
        if (ev.target === queueAlbumModal) { closeQueueAlbumModal(); return; }
        const el = ev.target instanceof Element ? ev.target : null;
        if (!el) return;

        const artistLink = el.closest('button[data-open-artist-albums]');
        if (artistLink) {
          const artist = decodeURIComponent(String(artistLink.getAttribute('data-open-artist-albums') || ''));
          try { await openArtistAlbumsModal({ artist }); } catch {}
          return;
        }

        const openAlb = el.closest('button[data-open-album]');
        if (openAlb) {
          const album = decodeURIComponent(String(openAlb.getAttribute('data-open-album') || ''));
          const artist = decodeURIComponent(String(openAlb.getAttribute('data-open-artist') || ''));
          const art = decodeURIComponent(String(openAlb.getAttribute('data-open-art') || ''));
          try { await openQueueAlbumModal({ album, artist, art }); } catch {}
          return;
        }

        const trk = el.closest('button[data-track-action][data-track-file]');
        if (trk) {
          const action = String(trk.getAttribute('data-track-action') || '');
          const file = decodeURIComponent(String(trk.getAttribute('data-track-file') || ''));
          if (!file) return;
          trk.setAttribute('disabled', 'disabled');
          try {
            if (action === 'play') await sendHeroPlayback('playfile', { file });
            else await sendHeroPlayback('addfile', { file });
            queueRefreshBurst();
            if (action === 'play') closeQueueAlbumModal();
          } catch {}
          trk.removeAttribute('disabled');
          return;
        }

        const artistAction = el.closest('button[data-artist-action][data-artist]');
        if (artistAction) {
          const artist = decodeURIComponent(String(artistAction.getAttribute('data-artist') || ''));
          const mode = 'replace';
          const minRating = Number(document.getElementById('queueArtistMinRating')?.value || 2);
          artistAction.setAttribute('disabled', 'disabled');
          try {
            await sendHeroPlayback('addartistshuffle', { artist, mode, minRating });
            queueRefreshBurst();
            closeQueueAlbumModal();
          } catch {}
          artistAction.removeAttribute('disabled');
          return;
        }

        const alb = el.closest('button[data-album-action][data-album]');
        if (alb) {
          const mode = String(alb.getAttribute('data-album-action') || 'append');
          const album = decodeURIComponent(String(alb.getAttribute('data-album') || ''));
          const artist = decodeURIComponent(String(alb.getAttribute('data-artist') || ''));
          alb.setAttribute('disabled', 'disabled');
          try {
            await sendHeroPlayback('addalbum', { mode, album, artist });
            queueRefreshBurst();
            closeQueueAlbumModal();
          } catch {}
          alb.removeAttribute('disabled');
        }
      });
      const HERO_QUEUE_COLLAPSED_KEY = 'nowplaying.app.heroQueueCollapsed';
      let queueCollapsed = false;

      function updateQueueCollapsedUi(){
        if (hqWrap) hqWrap.style.display = queueCollapsed ? 'none' : '';
        if (hqBtn) hqBtn.textContent = queueCollapsed ? 'Expand' : 'Collapse';
        if (hqClear) hqClear.style.display = queueCollapsed ? 'none' : '';
        if (hqCrop) hqCrop.style.display = queueCollapsed ? 'none' : '';
        if (hqSave) hqSave.style.display = queueCollapsed ? 'none' : hqSave.style.display;
        if (hqArrowWrap) hqArrowWrap.style.display = queueCollapsed ? 'none' : '';
        if (hqNextUp) hqNextUp.style.display = queueCollapsed ? 'flex' : 'none';

        if (hqBtn && hqNextUp && hqActionsHead) {
          if (queueCollapsed) {
            if (hqBtn.parentElement !== hqNextUp) hqNextUp.appendChild(hqBtn);
            hqBtn.style.marginLeft = 'auto';
          } else {
            if (hqBtn.parentElement !== hqActionsHead) hqActionsHead.appendChild(hqBtn);
            hqBtn.style.marginLeft = '';
          }
        }
      }

      if (hqBtn && hqWrap) {
        let collapsed = false;
        try {
          const saved = String(localStorage.getItem(HERO_QUEUE_COLLAPSED_KEY) || '').trim().toLowerCase();
          collapsed = (saved === '1' || saved === 'true' || saved === 'yes' || saved === 'on');
        } catch {}
        queueCollapsed = collapsed;
        updateQueueCollapsedUi();
        updateSavePresetsButtonVisibility();

        hqBtn.addEventListener('click', () => {
          collapsed = !collapsed;
          queueCollapsed = collapsed;
          updateQueueCollapsedUi();
          updateSavePresetsButtonVisibility();
          try { localStorage.setItem(HERO_QUEUE_COLLAPSED_KEY, collapsed ? '1' : '0'); } catch {}
        });

        hqClear?.addEventListener('click', async () => {
          hqClear.disabled = true;
          try { await sendHeroPlayback('clear'); } catch (_) {}
          finally { hqClear.disabled = false; await syncHeroQueue(); }
        });

        hqCrop?.addEventListener('click', async () => {
          hqCrop.disabled = true;
          try { await sendHeroPlayback('crop'); } catch (_) {}
          finally { hqCrop.disabled = false; await syncHeroQueue(); }
        });

        hqSave?.addEventListener('click', () => {
          try { saveCurrentQueueAsRadioPreset(); } catch {}
        });

        hqWrap.addEventListener('click', async (ev) => {
          const el = ev.target instanceof Element ? ev.target : null;
          if (!el) return;

          const albumBtn = el.closest('button[data-queue-album]');
          if (albumBtn) {
            ev.stopPropagation();
            const album = decodeURIComponent(String(albumBtn.getAttribute('data-queue-album') || ''));
            const artist = decodeURIComponent(String(albumBtn.getAttribute('data-queue-artist') || ''));
            const title = decodeURIComponent(String(albumBtn.getAttribute('data-queue-title') || ''));
            const art = decodeURIComponent(String(albumBtn.getAttribute('data-queue-art') || ''));
            openQueueAlbumModal({ album, artist, title, art });
            return;
          }

          const moveBtn = el.closest('button[data-move-pos][data-move-dir]');
          if (moveBtn) {
            ev.stopPropagation();
            const fromPosition = Number(moveBtn.getAttribute('data-move-pos') || 0);
            const dir = String(moveBtn.getAttribute('data-move-dir') || '');
            if (!Number.isFinite(fromPosition) || fromPosition <= 0) return;
            const toPosition = dir === 'up' ? (fromPosition - 1) : (fromPosition + 1);
            if (toPosition <= 0) return;
            moveBtn.disabled = true;
            try { await sendHeroPlayback('move', { fromPosition, toPosition }); }
            catch (_) {}
            finally { moveBtn.disabled = false; await syncHeroQueue(); }
            return;
          }

          const removeBtn = el.closest('button[data-remove-pos]');
          if (removeBtn) {
            ev.stopPropagation();
            const pos = Number(removeBtn.getAttribute('data-remove-pos') || 0);
            if (!Number.isFinite(pos) || pos <= 0) return;

            const row = removeBtn.closest('.heroQueueRow');
            if (row) {
              row.style.opacity = '.45';
              row.style.pointerEvents = 'none';
            }
            removeBtn.disabled = true;
            setQueueBusyHint('removingâ€¦');

            try {
              await sendHeroPlayback('remove', { position: pos });
              // optimistic hide so user gets immediate feedback
              if (row) row.style.display = 'none';
            } catch (_) {
              if (row) {
                row.style.opacity = '';
                row.style.pointerEvents = '';
                row.style.display = '';
              }
            } finally {
              removeBtn.disabled = false;
              await syncHeroQueue();
              setQueueBusyHint('');
            }
            return;
          }

          const row = el.closest('[data-queue-play-pos]');
          if (!row) return;
          const pos = Number(row.getAttribute('data-queue-play-pos') || 0);
          if (!Number.isFinite(pos) || pos <= 0) return;
          markQueueRowActiveOptimistic(pos);
          try { await sendHeroPlayback('playpos', { position: pos }); }
          catch (_) {}
          finally { await syncHeroQueue(); }
        });
      }

      const HERO_ARROW_KEYS_ENABLED_KEY = 'nowplaying.app.arrowKeysEnabled';
      const arrowKeysEl = document.getElementById('heroQueueArrowKeys');

      function readArrowPref(){
        const isOn = (v) => ['1','true','yes','on'].includes(String(v || '').trim().toLowerCase());
        try {
          const v = localStorage.getItem(HERO_ARROW_KEYS_ENABLED_KEY);
          if (v != null && String(v).trim() !== '') return isOn(v);
        } catch {}
        try {
          const v = sessionStorage.getItem(HERO_ARROW_KEYS_ENABLED_KEY);
          if (v != null && String(v).trim() !== '') return isOn(v);
        } catch {}
        try {
          const m = document.cookie.match(new RegExp(`(?:^|; )${HERO_ARROW_KEYS_ENABLED_KEY.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}=([^;]*)`));
          if (m && m[1] != null) return isOn(decodeURIComponent(m[1]));
        } catch {}
        return false;
      }

      function writeArrowPref(on){
        const v = on ? '1' : '0';
        try { localStorage.setItem(HERO_ARROW_KEYS_ENABLED_KEY, v); } catch {}
        try { sessionStorage.setItem(HERO_ARROW_KEYS_ENABLED_KEY, v); } catch {}
        try { document.cookie = `${HERO_ARROW_KEYS_ENABLED_KEY}=${encodeURIComponent(v)}; path=/; max-age=${60*60*24*365}`; } catch {}
      }

      let arrowKeysEnabled = readArrowPref();
      if (arrowKeysEl) {
        arrowKeysEl.checked = !!arrowKeysEnabled;
        arrowKeysEl.addEventListener('change', () => {
          arrowKeysEnabled = !!arrowKeysEl.checked;
          writeArrowPref(arrowKeysEnabled);
        });
      }

      function canHandleTransportHotkey(ev){
        if (!arrowKeysEnabled) return false;
        if (!ev) return false;
        if (ev.defaultPrevented) return false;
        if (ev.metaKey || ev.ctrlKey || ev.altKey) return false;
        const ae = document.activeElement;
        if (!ae) return true;
        const tag = String(ae.tagName || '').toLowerCase();
        if (tag === 'input' || tag === 'textarea' || tag === 'select') return false;
        if (ae.isContentEditable) return false;
        return true;
      }

      function getActiveQueuePosFromDom(){
        const rows = Array.from(document.querySelectorAll('#heroQueueWrap .heroQueueRow[data-queue-play-pos]'));
        if (!rows.length) return 0;
        for (const row of rows) {
          const bg = String(row.style.background || '').toLowerCase();
          if (bg.includes('34,197,94')) {
            const p = Number(row.getAttribute('data-queue-play-pos') || 0);
            if (Number.isFinite(p) && p > 0) return p;
          }
        }
        for (const row of rows) {
          if (String(row.textContent || '').includes('â–¶')) {
            const p = Number(row.getAttribute('data-queue-play-pos') || 0);
            if (Number.isFinite(p) && p > 0) return p;
          }
        }
        return Number(rows[0].getAttribute('data-queue-play-pos') || 0) || 0;
      }

      window.addEventListener('keydown', (ev) => {
        const k = String(ev.key || '');
        if (k === 'Escape' && queueAlbumModal?.classList.contains('open')) {
          ev.preventDefault();
          closeQueueAlbumModal();
          return;
        }
        if (k !== 'ArrowLeft' && k !== 'ArrowRight') return;
        if (!canHandleTransportHotkey(ev)) return;
        if (ev.repeat) return;

        const action = (k === 'ArrowLeft') ? 'previous' : 'next';
        const btn = document.querySelector(`#heroTransport button[data-a="${action}"]`);
        if (!btn) return;

        const cur = getActiveQueuePosFromDom();
        if (cur > 0) {
          const nextPos = k === 'ArrowLeft' ? Math.max(1, cur - 1) : (cur + 1);
          markQueueRowActiveOptimistic(nextPos);
        }

        ev.preventDefault();
        try { btn.click(); } catch {}
      });

      syncFrameWidth();
      navigate(getPageFromUrl(), false);
      syncPills();
      syncHeroQueue();
      setInterval(() => { if (!document.hidden) syncPills(); }, 30000);
      setInterval(() => { if (!document.hidden) syncHeroQueue(); }, 7000);
      setInterval(() => { if (!document.hidden) syncFrameHeight(); }, 4000);
    })();
  </script>
</body>
</html>
